%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%        Treaps com chave implícita            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Árvore binária de busca com chave implícita}
\label{sec:TreapDeChaveImplicita}

Com uma implementação tradicional de ABB, em que o campo $chave$ dos nós de uma ABB~$T$ com $t$ nós armazena explicitamente os números de $1$ a $t$, é necessário, na operação \treapJoin($T$, $R$), atualizar todas as chaves de~$R$ para que possuam os valores $1+t,2+t, \ldots, r+t$, onde $r$ é o número de nós em~$R$.

Analogamente, com essa implementação tradicional, ao realizar \treapSplit($T$, $\node$) é necessário atualizar todos os nós com chave maior do que a chave de $\node$.
No pior dos casos, essas atualizações de chaves podem custar tempo $\OTheta{n}$, onde $n$ é o tamanho das árvores envolvidas.

Para reduzir o número de atualizações desse campo, na biblioteca de Euler tour trees, as ABBs utilizadas possuirão \defi{chave implícita}, ou seja, substituímos o campo $chave$ de cada nó pelo campo \defi{tam} que armazena o tamanho da subárvore enraizada naquele nó, isto é, o número de nós nessa subárvore.
Com esse novo campo, a chave de cada nó pode ser determinada em tempo proporcional à profundidade do nó na ABB.

\begin{figure}[htb]
\centering
\input{fig/SEQ-SIZE.tex}
\caption{Árvore da Figura~\ref{fig:seq-treap-indices} exibindo o valor do campo $tam$ abaixo de cada nó.}
\label{fig:seq-treap-size}
\end{figure}

\newpage
Com essa mudança, em \treapJoin{} e \treapSplit{}, será necessário ajustar apenas o campo $tam$ de um número bem mais reduzido de nós, o que resultará em uma implementação com o consumo de tempo desejado.

Como manipularemos muitos ponteiros a ABBs que podem conter $\Nil$, é conveniente a adição da rotina interna \treapGetSize($T$), descrita no Algoritmo~\ref{Algo:treapGetSize}, que retorna $0$ caso $T$ contenha~$\Nil$ e, no caso em que $T$ aponte para uma ABB não vazia, retorna seu tamanho. Essa rotina consome tempos~$\O{1}$.

\begin{algorithm}[!htb]
\caption{\treapGetSize($T$)}
\label{Algo:treapGetSize}
\begin{algorithmic}[1]
\If { $T$ = \Nil}
\State \Return $0$
\EndIf
\State \Return $T$.$tam$
\end{algorithmic}
\end{algorithm}

Com chaves implícitas, a alteração de um nó $x$ torna necessário somente a atualização do campo $tam$ dos nós contidos no caminho entre o nó $x$ e a raiz da ABB que o contém, ou seja, o consumo de tempo dessas atualizações será assintoticamente proporcional à altura da ABB. Resta então o desafio de manter a ABB balanceada. Na próxima seção apresentaremos a estrutura de dados treap, que resolve esse desafio sem onerar o custo assintótico das operações ou adicionar demasiada complexidade aos algoritmos.

\section{Treaps}

\defi{Heaps} são árvores binárias quase completas constituídas por nós que possuem quatro campos: prioridade, pai e filhos esquerdo e direito~\cite{CLRS}. Os campos referentes aos pais e filhos dão a estrutura de árvore binária ao heap e a \defi{prioridade} de um nó é um inteiro não negativo. Não apresentaremos a definição de árvore binária quase completa, pois ela é desnecessária para a definição de treaps. Para que uma árvore binária quase completa seja considerada um heap é necessário que a prioridade de cada nó seja maior do que a de seus filhos.

\defi{Treaps} são uma mescla entre árvores binária de busca e heaps. Seus nós possuem cinco campos: $pai$, $esq$, $dir$, $chave$ e $prio$. Os campos $esq$ e $dir$ representam os filhos esquerdo e direito de cada nó, respectivamente, e junto ao campo $pai$ descrevem a estrutura de uma árvore binária. O campo $chave$ satisfaz a propriedade de uma ABB enquanto o campo $prio$ armazena a prioridade do nó e satisfaz a propriedade de um heap. Diferentemente de heaps, treaps não precisam ser quase completas.


Tais árvores foram inicialmente nomeadas \defi[arvore@\'arvore!cartesiana]{árvores cartesianas} \cite{Vuillemin1980AUL}, pois podemos representar cada nó como um par ordenado em que a primeira coordenada é a chave do nó e a segunda coordenada é sua prioridade. Ao visualizar esses pares imersos no plano cartesiano, como feito na Figura \ref{fig:TREAP}, ambas as estruturas de ABB e heap são bem representadas. Isto é, nós com maior prioridade ficam ilustrados acima de nós com menor prioridade e os nós ficam ordenados de forma crescente, da esquerda para a direita, em função de suas chaves.

\begin{figure}[htb]
\centering
\input{fig/TREAP.tex}
\caption{Uma treap imersa no plano cartesiano.}
\label{fig:TREAP}
\end{figure}

\section{Implementação de árvore binária de busca de chave implícita com treaps}
\label{sec:imple-treap}
A implementação da rotina \treapGetRoot{}, apresentada no Algoritmo~\ref{Algo:treapGetRoot}, independe da técnica que usaremos para balancear a treap,
pois é uma consulta e somente usa a estrutura da ABB sem fazer modificações.
Seu consumo de tempo é~$\O{h}$ onde~$h$ é a altura da árvore.

\begin{algorithm}[htb]
\caption{\treapGetRoot($\node$)}
\label{Algo:treapGetRoot}
\begin{algorithmic}[1]
\State $raiz$ $\gets$ $\node$
\While {$raiz$.$pai$ $\neq \Nil$}
\State  $raiz$ $\gets$  $raiz$.$pai$
\EndWhile
\State \Return $raiz$
\end{algorithmic}
\end{algorithm}

Para balancear uma treap e assim garantir consumo de tempo logarítmico, Seidel e Aragon~\cite{AragonSeidel1996} propuseram escolher a prioridade de cada nó de forma aleatória com distribuição de probabilidade uniforme em um universo suficientemente grande para que a probabilidade de haver nós com a mesma prioridade seja próxima de~$0$.

Para representar essa escolha aleatória, usaremos uma função auxiliar \random($r$) que retorna um inteiro positivo menor do que $r$ com probabilidade uniforme. Esse tipo de função está presente nativamente em diversas linguagens de programação e a elaboração de sua implementação foge do escopo desse texto. Consideraremos que seu consumo de tempo é~$\O{1}$.

Com essa técnica de balanceamento de treaps em mãos, podemos apresentar a implementação dos demais algoritmos que compõem essa biblioteca.
O primeiro desses é \treapCreate($u$, $v$), que recebe vértices~$u$ e~$v$, cria um nó de treap chamado $\node$, inicializa seus campos apropriadamente e o retorna.
Essa rotina consome tempo~$\O{1}$. 

\begin{algorithm}
\caption{\treapCreate($u$, $v$)}
\label{Algo:TREAPbuild}
\begin{algorithmic}[1]
\State $\node$.$tam$ $\gets 1$
\State $\node$.$prio$ $\gets$ \random(\TODO{r})
\State $\node$.$info$ $\gets$ ($u$, $v$)
\State $\node$.$esq$ $\gets$ $\node$.$dir$ $\gets$ $\node$.$pai$ $\gets$ \Nil
\State \Return $\node$
\end{algorithmic}
\end{algorithm}

No capítulo anterior, definimos o protótipo da rotina \treapJoin{} como sendo \treapJoin($T_1, T_2, \ldots, T_k$).
Essa rotina junta as ABBs $T_1, T_2, \ldots, T_{k-1}$ e $T_k$ de modo que a sequência armazenada na árvore resultante é a concatenação das sequências armazenada em~$T_1, T_2, \ldots, T_k$ e retorna a raiz dessa árvore resultante.
Aqui elaboraremos o caso em que $k=2$ e assim adotaremos o cabeçalho~\treapJoin($T$, $R$) para esse algoritmo, cuja implementação pode ser vista no Algoritmo~\ref{Algo:TREAPjoin}.
A generalização a partir desse caso particular é imediata.

\begin{algorithm}
\caption{\treapJoin($T$, $R$)}
\label{Algo:TREAPjoin}
\begin{algorithmic}[1]
\If { $T$ = \Nil} \Return $R$
\EndIf
\If { $R$ = \Nil} \Return $T$
\EndIf

\If { $T$.$prio$ $>$ $R$.$prio$}\label{algo:TREAPjoin:if}
  \State $T$.$dir$ $\gets$ \treapJoin($T$.$dir$, $R$)
  \State $T$.$dir$.$pai$ $\gets$ $T$
  \State $T$.$tam$ $\gets$ $T$.$tam$ + $R$.$tam$
  \State \Return $T$
\Else 
  \State $R$.$esq$ $\gets$ \treapJoin($T$, $R$.$esq$)
  \State $R$.$esq$.$pai$ $\gets$ $R$
  \State $R$.$tam$ $\gets$ $T$.$tam$ + $R$.$tam$
  \State \Return $R$
\EndIf
\end{algorithmic}
\end{algorithm}

Para compreender o funcionamento de~\treapJoin{} podemos utilizar a ideia da imersão das treaps no plano cartesiano para visualizar melhor suas estruturas.
Na Figura~\ref{fig:treap-join}, podemos ver um exemplo de treaps~$T$ e~$R$.

Após tratar os casos em que~$T$ ou~$R$ podem ser~$\Nil$, precisamos definir o nó que será a raiz da junção das duas árvores.
Este nó será aquele com maior prioridade, assim mantendo a propriedade de heap, essa comparação é feita na linha~\ref{algo:TREAPjoin:if}.

Se a prioridade da raiz de~$T$ for maior do que a de~$R$, como ilustrado na Figura~\ref{fig:treap-join}, então devemos juntar~$R$ a alguma subárvore de~$T$.
Como usamos chaves implícitas e a sequência contida em~$R$ ficará após a sequência contida em~$T$ depois da junção dessas árvores,
temos que todas as chaves de~$R$ são estritamente maiores do que as chaves de~$T$, logo temos que recursivamente juntar~$R$ com a subárvore enraizada no nó $T$.$dir$.
Em seguida, corrigimos o campo $pai$ de $T$.$dir$ e o campo~$tam$ de~$T$.


\begin{figure}[htb]
\centering
\input{fig/TREAP-join.tex}
\caption{Exemplo de duas treaps imersas no plano cartesiano.}
\label{fig:treap-join}
\end{figure}


Caso a prioridade de~$R$ seja maior do que a de~$T$, então temos juntar recursivamente $T$ com a subárvore enraizada em~$R$.$esq$. Esse caso é simétrico ao anterior.
Podemos ver o resultado da junção das treaps~$T$ e~$R$ da Figura~\ref{fig:treap-join} na Figura~\ref{fig:treap-join-depois}.




\begin{figure}[htb]
\centering
\input{fig/TREAP-join-depois.tex}
\caption{Resultado da junção das treaps~$T$ e~$R$ da Figura~\ref{fig:treap-join}. Ponteiros modificados estão destacados em vermelho.}
\label{fig:treap-join-depois}
\end{figure}
Notemos que \treapJoin{} consome $\O{h}$ onde~$h$ é a soma das alturas das duas árvores que são unidas.
Como a altura esperada dessas árvores é $\O{\lg n}$, temos que o consumo esperado de tempo dessas duas rotinas também será logarítmico.


A implementação da rotina~\treapSplit($\node$) pode ser vista no Algoritmo~\ref{Algo:TREAPsplit}.
Nesse algoritmo percorremos o caminho de~$\node$ até sua raiz reatribuindo a relação de parentesco entre os nós percorridos de forma a cortar a treap em duas:
a primeira contendo todos os nós com chave menor do que a chave de~$\node$ e a segunda com todos os nós com chave maior do que~$\node$.
Para fazer isso mantemos três ponteiros: $L$, $R$ e~$tmp$. 
Os dois primeiros apontam para as raízes das árvores resultantes desse corte e o terceiro aponta para o nó cuja relação de parentesco será modificada.

\begin{algorithm}
\caption{\treapSplit($\node$)}
\label{Algo:TREAPsplit}
\begin{algorithmic}[1]
\State $R$ $\gets $ $\node$.$dir$
\State $L$ $\gets $ $\node$.$esq$
\State $tmp$ $\gets$ $\node$
\While { $tmp$.$pai$ $\neq \Nil$}
  \If { $tmp$.$pai$.$esq$ = $tmp$}
    \State $tmp$.$pai$.$esq$ $\gets$ $R$
    \State $tmp$.$pai$.$tam$ $\gets$ $tmp$.$pai$.$tam$ $\mathit{-}$ \treapGetSize($L$)
    \If { $R \neq \Nil$}
    \State $R$.$pai$ $\gets$ $tmp$.$pai$
    \EndIf
    \State $R$ $\gets$ $tmp$.$pai$
  \Else
    \State $tmp$.$pai$.$dir$ $\gets$ $L$ 
    \State $tmp$.$pai$.$tam$ $\gets$ $tmp$.$pai$.$tam$ $\mathit{-}$ \treapGetSize($R$)
    \If { $L$ $\neq$ \Nil}
    \State $L$.$pai$ $\gets$ $tmp$.$pai$
    \EndIf
    \State $L$ $\gets$ $tmp$.$pai$
  \EndIf
  \State $tmp$ $\gets$ $tmp$.$pai$
\EndWhile
\If { $L$ $\neq \Nil$} $L$.$pai$ $\gets\Nil$\EndIf
\If { $R$ $\neq \Nil$} $R$.$pai$ $\gets\Nil$\EndIf
\State $\node$.$dir$ $\gets $ $\node$.$esq$ $\gets$ $\node$.$pai$ $\gets$ $\Nil$
\State\Return $L$, $R$
\end{algorithmic}
\end{algorithm}

Simularemos a execução de $\treapSplit(X)$, onde $X$ é o nó de coordenadas $(6,3)$ da Figura~\ref{fig:treap-join-depois}.
O estado inicial dos ponteiros~$L$ e~$R$ são os filhos de~$X$ e~$tmp$ aponta para~$X$, como mostra a Figura~\ref{fig:treap-split-1}.

Se~$tmp$ for filho esquerdo de seu pai, isto é $tmp$.$pai$.$esq$ $=$ $tmp$, então a chave de $tmp$.$pai$ é maior do que a chave de~$X$ e ele logo deve ser um nó de~$R$.
Além disso, sabemos que a prioridade e chave de $tmp$.$pai$ são maiores do que a prioridade e chave de~$R$,
logo~$R$ é o filho esquerdo de~$tmp$.$pai$ e~$tmp$.$pai$ deve ser a nova raiz de~$R$. 
Após atualizar os campos de parentesco entre~$R$, $tmp$ e $tmp$.$pai$, atualizamos o valor de~$tmp$ para $tmp$.$pai$, obtemos o estado mostrado na Figura~\ref{fig:treap-split-2}.
Então repetimos esse processo. 

\begin{figure}[htb]
\begin{subfigure}{0.3\textwidth}
\input{fig/TREAP-split-1.tex}
\caption{Estado inicial dos ponteiros $L$, $R$ e $tmp$.}
\label{fig:treap-split-1}
\end{subfigure}
\hspace{3cm}
\begin{subfigure}{0.3\textwidth}
\input{fig/TREAP-split-2.tex}
\caption{Estado após atualização dos ponteiros de parentesco.}
\label{fig:treap-split-2}
\end{subfigure}
\caption{Dois estados da simulação de~\treapSplit(X).}
\end{figure}

Na próxima iteração desse laço, repetimos o processo descrito no parágrafo anterior, pois temos que o nó apontado por~$tmp$ é filho esquerdo de seu pai.
Já na próxima iteração, fazemos as operações simétricas, pois teremos que o nó apontado por $tmp$ é filho direito de seu pai.
Ao término dessa iteração, obtemos as treaps da Figura~\ref{fig:treap-split-final}.

Notemos que \treapSplit{} consiste em um laço que percorre os nós de uma treap até sua raiz e em cada nó realiza operações de custo constante, logo seu consumo de tempo é proporcional a altura da treap e, como essa é balanceada, temos que seu consome esperado é $\O{\lg n}$.

\begin{figure}[htb]
\centering
\input{fig/TREAP-split-final.tex}
\caption{Resultado de~\treapSplit(X).}
\label{fig:treap-split-final}
\end{figure}
