\chapter{Introdução}

\section{Motivação}
\label{sec:Motivação}

Problemas em grafos servem para modelar uma série de aplicações do dia a dia,
e há uma vasta e clássica literatura que aborda vários problemas centrais em grafos.
Estes problemas clássicos geralmente consideram um modelo estático da situação. Ou seja, o grafo dado a priori não sofre alterações enquanto estamos resolvendo o problema.

Há no entanto aplicações em que o grafo modela uma situação menos estática. Por exemplo, em redes de dispositivos de internet das coisas, chuvas, ventos fortes ou falha na fonte de energia podem prejudicar a conexão entre dispositivos, o que pode ser representado pela remoção de uma aresta no grafo que abstrai a rede.

\defi{Algoritmos em grafos dinâmicos} é o termo usado para se referir à área de projeto de algoritmos que se concentra em resolver problemas clássicos de forma eficiente nesse contexto em que o grafo está sofrendo alterações. A literatura nessa área tem mais de $40$ anos e muito progresso significativo tem ocorrido recentemente. No entanto, há uma carência de material escrito $-$ especialmente em português $-$ nos livros de algoritmos sobre essa área tão atraente e atual.

Formalmente, um \defi[grafo!dinâmico]{grafo dinâmico} de ordem~$n$ é uma sequência de grafos~$(G_0, G_1,\ldots, G_T)$, onde~$G_0$ é um grafo com $n$ vértices e
cada $G_t$ para $1\leq t\leq T$ é obtido a partir de $G_{t-1}$ pela adição ou remoção de uma aresta.
Ou seja,~$E(G_t) := E(G_{t-1})\cup \{uv\}$, para alguma aresta~$uv\notin E(G_{t-1})$;
ou $E(G_t) := E(G_{t-1})\setminus \{uv\}$, onde~$uv\in E(G_{t-1})$, respectivamente.
As operações de adição e remoção de arestas são chamadas de \defi{modificações} ou \defi{atualizações} do grafo dinâmico.
\NEW{
Nos problemas que estudaremos nesse texto, consideraremos que~$G_0$ não possui arestas.
}

Há aplicações em que as conexões possuem um custo ou peso associado,
representando a latência de comunicação entre dispositivos ou o custo de construção de uma infraestrutura cabeada, por exemplo. 
Para lidar com tais aplicações, associa-se um valor real a cada aresta do grafo.
Nesse caso, o grafo resultante é chamado de \defi[grafo!ponderado]{ponderado}.
Em um problema com grafos dinâmicos ponderados, além de inserções e remoções de arestas, também é considerada a operação
de mudança de peso de uma determinada aresta como uma operação de atualização válida.

Um problema em grafos dinâmicos envolve verificar se~$G_t$ satisfaz alguma determinada propriedade, para um dado~$0\leq t\leq T$.
A operação de verificação dessa propriedade é chamada de \defi{consulta}.
Solucionar um tal problema envolve desenvolver um algoritmo ou estrutura de dados capaz de dar suporte às modificações e consultas de forma eficiente.

Em alguns casos, restringimos cada~$G_t$ a uma família de grafos, como, por exemplo, florestas ou~\defi[grafo!plano]{grafos planos}, isto é, um grafo que é planar, com uma imersão específica no plano.

Trabalhar com essas classes mais restritas de grafos permite o desenvolvimento de algoritmos mais simples que podem servir de etapa intermediária para se obter uma solução para o problema geral ou ser de interesse para alguma aplicação específica.
Usaremos a primeira estratégia no estudo do nosso primeiro problema:
O \defi[problema!de conexidade em!grafos dinâmicos]{problema de conexidade em grafos dinâmicos}, que consiste em, dado um grafo dinâmico submetido a uma sequência de inserções e remoções de arestas, responder a consultas do tipo “Os vértices $u$ e $v$ estão conectados por um caminho?”.

Vamos primeiro tratar o caso em que o grafo dinâmico é uma floresta, isto é, trabalharemos com o \defi[problema!de conexidade em!florestas dinâmicas]{problema de conexidade em florestas dinâmicas},
para em seguida usar as estruturas de dados desenvolvidas nesse problema para solucionar o caso geral.

O segundo problema estudado também será restrito a uma classe específica de grafos.
Estudaremos o \defi[problema!da floresta maximal de peso mínimo em grafos ponderados dinâmicos]{problema da floresta maximal de peso mínimo em grafos ponderados dinâmicos} restrito a grafos planos.
Esse problema visa manter uma \defi{floresta maximal de peso mínimo} (MSF) de um grafo dinâmico ponderado plano ao longo da sequência de modificações.

Começaremos esse estudo na próxima seção, em que faremos uma revisão histórica dos resultados relacionados aos problemas que serão abordados nos próximos capítulos.
No Capítulo~\ref{sec:connDF}, estudaremos o problema de conexidade em florestas dinâmicas e uma de suas soluções, proposta por Holm, de Lichtenberg e Thorup~\cite{poly_log}, que envolve Euler tour trees.
Essa estrutura de dados utiliza árvores binárias de busca de chave implícita, cuja implementação será elaborada no Capítulo~\ref{sec:TreapDeChaveImplicita}.
No Capítulo~\ref{sec:connDG}, expandiremos nosso estudo sobre conexidade estudando o problema de conexidade em grafos dinâmicos.

No Capítulo~\ref{sec:avaliacao-empirica} apresentaremos um estudo experimental envolvendo o algoritmo explicado no Capítulo~\ref{sec:connDG}, incluindo experimentos com classes específicas de grafos.
No Capítulo~\ref{sec:MSF}, apresentaremos um algoritmo proposto por Eppstein et al.~\cite{EPPSTEIN-planar} para solucionar o problema da floresta maximal de peso mínimo em grafos ponderados dinâmicos planos. 

No Capítulo~\ref{sec:lim}, demonstraremos um limitante inferior de~$\Omega(\lg n)$ por operação para todos os problemas estudados. Esse limitante mostra que os algoritmos apresentados para o problema de conexidade em florestas dinâmicas e para o problema da floresta maximal de peso mínimo em grafos ponderados dinâmicos planos são ótimos.
No Capítulo~\ref{sec:conclusao} 
\NEW{
faremos considerações finais sobre nossos estudos.
}

\section{Historiografia}

Essa seção é inspirada na historiografia apresentada em \cite{QC22, HHSRecentAdvances2022, bruceM}.

Soluções para os problemas de conexidade dinâmica e de floresta maximal de peso mínimo se desenvolveram em paralelo ao longo dos anos. Em $1975$, Spira e Pan~\cite{SP1975} atacaram o problema MSF propondo um algoritmo cuja complexidade é $\O{n}$ para inserção e $\O{n^2}$ para remoção de arestas, onde $n$ é o número de vértices do grafo. Três anos depois, Chin e Houck~\cite{CH1978} apresentaram uma solução mais simples para inserção e remoção de arestas que possui o mesmo consumo de tempo que o algoritmo de Spira e Pan.

Em $1985$, Frederickson~\cite{frederickson1983data} reduziu a complexidade de ambas as operações de modificação para $\O{\!\sqrt{m}}$, onde~$m$ é o número de arestas do grafo no momento em que a operação é aplicada.
Em $1997$, Eppstein et al.~\cite{Eppstein1992SparsificationaTF} melhoraram o consumo de tempo do algoritmo de Frederickson para~$\O{\!\sqrt{n}}$.
Neste mesmo ano, foi realizado o primeiro experimento de desempenho prático, testando diferentes versões do algoritmo de Frederickson~\cite{xpAnalyGiuseppe}.

O primeiro algoritmo poli-logarítmico para o problema de conectividade dinâmica foi apresentado por Henzinger e King~\cite{HenzingerKing} e possui consumo amortizado esperado $\O{\lg^3 n}$ para cada operação. Nesse artigo, elas introduziram uma estrutura de dados chamada Euler tour trees como uma maneira eficiente de representar florestas dinâmicas. Em seguida, em $1997$, seu consumo esperado por operação foi reduzido a $\O{\lg^2 n}$~\cite{HenzingerThorup}.  Implementações e avaliações experimentais foram feitas sobre essa solução para os problemas~\cite{EmpiricalStudy1997, EmpiricalStudy2002, Zaroliagis2002}.

Inspirados na solução de Henzinger e King para o problema de conexidade dinâmica, em $2001$, Holm, de Lichtenberg e Thorup~\cite{poly_log} atacaram ambos os problemas de conectividade dinâmica e de MSF usando Euler tour trees.
A solução deles para o problema de conexidade empata com o consumo assintótico da solução de Henzinger e King de~$\O{\lg^2 n}$.
No entanto, se a implementação das Euler tour trees for determinística, então o algoritmo para conexidade dinâmica de Holm et al. é completamente determinístico e seu consumo é somente amortizado,
enquanto que o consumo na solução de Henzinger e King é esperado e amortizado. 
Apresentaremos a solução de Holm et al. nesse texto com uma implementação aleatorizada de Euler tour trees.

O algoritmo de Holm et al. para MSF possui consumo amortizado $\O{\lg^4 n}$ para cada operação, sendo assim a primeira estrutura de dados determinística com consumo de tempo poli-logarítmico para o problema MSF. Uma implementação eficiente deste algoritmo foi apresentada por Cattaneo et al. \cite{xpstudy2002} junto a um outro algoritmo mais simples e assintoticamente pior, mas que teve bom desempenho nos experimentos práticos realizados.

Em $2000$, Thorup~\cite{Thorup2000} complementou o algoritmo de Holm et al.~\cite{poly_log}, adicionando uma estrutura de dados auxiliar chamada floresta estrutural, que reduz o consumo de tempo de cada operação para~$\O{\lg n\, (\lg\lg n)^3}$ esperado amortizado.

Em $2006$, Patrascu e Demaine~\cite{lowerBoundPatrascu} provaram um limitante inferior de $\Omega(\lg n)$ para o consumo assintótico por operação para o problema de conexidade dinâmica.
Esse limitante pode ser facilmente aplicado ao problema da floresta maximal de peso mínimo.

Em $2010$, Tarjan e Werneck~\cite{tarjanWerneck2010} fizeram um estudo experimental com diversas estruturas de dados para árvores dinâmicas que resolvem o problema da floresta maximal de peso mínimo.

Em $2016$, Wulff-Nilsen~\cite{Wulff-Nilsen2016} apresentou um novo algoritmo para o problema de conexidade em grafos dinâmicos que dá suporte às atualizações com consumo~$\O{\frac{\lg^2 n}{\lg \lg n}}$ esperado amortizado e~$\O{\frac{\lg n}{\lg \lg n}}$ para a consulta de conexidade.

Desde $1997$, os algoritmos com consumo de tempo amortizado foram predominantes na literatura, porém todos possuem alguma instância com consumo de tempo $\OTheta{n}$ no pior caso.
O problema de melhorar o tempo assintótico no pior caso continuou a permear a literatura sem avanços até $2013$, quando Kapron, King e Mountjoy \cite{bruceM} apresentaram uma estrutura de dados para o problema de conexidade em grafos dinâmicos baseada no problema \textit{cutset} que proporciona consumo $\O{\lg^4 n}$ para a inserção de arestas, $\O{\lg^5 n}$ para remoção e responde à consulta de conexidade em tempo~$\O{\lg n / \lg(\lg n)}$.
A estrutura responde a consultas corretamente quando a resposta é “sim” e com alta probabilidade de acerto quando a resposta é “não”. A probabilidade de falso positivo, mesmo que baixa, continuou incentivando a pesquisa na área. 

Em $2015$, Kejlberg-Rasmussen et al.~\cite{kejlbergrasmussen_et_al} apresentaram uma estrutura de dados para o problema de conexidade em grafos dinâmicos que permite fazer consultas de conexidade em grafos dinâmicos em tempo constante, mas que possui consumo de tempo para as atualizações de~$\mathrm{O}\!\left(\sqrt{\frac{n\left(\lg \lg n\right)^2}{\lg n}}\right)$, um consumo de tempo assintótico consideravelmente maior do que os últimos algoritmos citados.

Em $2022$, Chen et al. \cite{QC22} propuseram uma heurística baseada no diâmetro do grafo dinâmico e com ela desenvolveram um algoritmo que possui bom desempenho prático quando aplicado a grafos dinâmicos extraídos de situações reais.
No entanto, quando o diâmetro do grafo em questão ultrapassa~$16$ arestas, algoritmos com consumo de tempo assintótico menor, como o de Henzinger e King~\cite{HenzingerKing}, o superam.
Nosso estudo experimental indica que o algoritmo de Holm et al.~\cite{poly_log} também supera o desempenho da heuristica de Chen et al. em grafos com diâmetro acima de $16$.
