\chapter{Floresta maximal de peso mínimo em grafos planos}
\label{sec:MSF}

O problema da floresta maximal de peso mínimo em grafos planos dinâmicos foi inicialmente apresentado na Seção~\ref{sec:Motivação} e é o segundo problema que iremos discutir.
O objetivo desse capítulo é apresentar o algoritmo de David Eppstein, Giuseppe Italiano, Roberto Tamassia, Robert Tarjan, Jeffery Westbrook e Moti Yung~\cite{EPPSTEIN-planar} que resolve esse problema para grafos planos que podem ter laços e arestas paralelas.

O estudo desse problema se inicia com uma revisão de conceitos de planaridade e dualidade apresentados nas Seções~\ref{sec:planaridade} e~\ref{sec:dualidade} respectivamente.
Esses conceitos são bem estabelecidos na literatura e essas seções são baseadas na Seção~4.2 do livro \textit{Graph Theory} de Reinhard Diestel~\cite{Diestel}.

Os conceitos apresentando nessas duas seções iniciais serão usados para definir formalmente o problema, o que é feito na Seção~\ref{sec:definition-MSF}, e para fundamentar a estrutura de dados que resolve esse problema, que será apresentada na Seção~\ref{sec:EODT}.

\section{Planaridade}
\label{sec:planaridade}

Intuitivamente, um grafo é dito plano se ele está desenhado em uma folha de papel de forma que suas arestas não se cruzem.
Formalmente, um \defi[grafo!plano]{grafo plano}~\cite{Diestel} é um par de conjuntos finitos $G = (V, E)$ com as seguintes propriedades:
\begin{enumerate}
\item $V\subset \R^2$;
\item Toda aresta é um arco entre dois vértices;
\item O interior de uma aresta não contém vértices nem intersecta outras arestas.
\end{enumerate}
Quando conveniente, $G$ será usado tanto para o par~$(V ,E)$ quanto para o conjunto~${V\cup\bigcup E}$.

Para cada grafo plano~$G$, ao remover~$G$ do plano~$\R^2$, é obtido um conjunto finito~$F(G)$ de regiões conexas que é chamado de \defi{conjunto de faces} de~$G$.
Naturalmente, cada uma dessas regiões é chamada de uma \defi{face} de $G$.
Uma dessas faces é ilimitada.
Essa face é chamada de \defi{face exterior}.
A Figura~\ref{fig:MSF-basico-0} mostra um grafo plano~$G$ e suas as faces.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-0.tex}
}
\caption{Um grafo ponderado plano e suas faces.}
\label{fig:MSF-basico-0}
\end{figure}



\begin{lemma}[Lemma 4.2.2~\cite{Diestel}]
\label{lemma:diestel}
Seja $G$ um grafo plano e $e$ uma de suas arestas.
\begin{enumerate}
\item Se $X$ é a fronteira de uma face de~$G$, então ou $e\subseteq X$ ou a intersecção de $X$ com o interior de $e$ é vazia.
\item Se $e$ pertence a um ciclo de $G$, então $e$ pertence à fronteira de exatamente duas faces distintas de $G$;
\item Se não existe ciclo que contém $e$, então $e$ pertence à fronteira de uma única face de~$G$.
\end{enumerate}
\end{lemma}

\begin{theorem}[Fórmula de Euler, Teorema 4.2.9~\cite{Diestel}]
\label{teo:MSFEuler}
Seja $G=(V,E)$ um grafo planar conexo com~$n$ vértices e~$m$ arestas. Toda imersão de~$G$ no plano possui o mesmo número $f$ de faces e
$$
n-m+f = 2.
$$
\end{theorem}

Para cada vértice $v$ de um grafo plano, é possível construir uma ordenação cíclica~$D(v)$ das aresta incidentes a~$v$~\cite{noma2003}.
Para obter essa ordenação, percorremos as arestas incidentes a~$v$ em sentido anti-horário até retornar à aresta inicial do percurso.
Uma aresta é dita \defi{sucessora} de outra aresta se a primeira é sucessora da segunda nesse percurso.
Uma lista de todas essas ordens cíclicas é chamada de~\defi{descrição combinatória plana} da imersão.
Abaixo temos uma descrição combinatória plana do grafo da Figura~\ref{fig:MSF-basico-0}.
\begin{align*}
D(u)&=\langle (a,u), (b,u), (c,u))\rangle\\
D(v)&=\langle (a,v), (e,v), (b,v)  \rangle\\
D(z)&=\langle (e,z), (d,z), (d,z), (c,z)\rangle
\end{align*}

A descrição combinatória de um grafo plano é essencialmente uma lista de adjacências em que a ordem das células é relevante.
Como estamos admitindo arestas paralelas, o número de ocorrências de um vértice~$u$ na lista de um vértice~$v$ será exatamente o número de arestas paralelas entre~$u$ e~$v$.
Um laço num vértice~$u$ corresponderá a duas ocorrências de~$u$ na sua lista de adjacências.

Para o algoritmo que vamos descrever nesse capítulo, cada aresta possui um identificador.
Observe que cada aresta corresponde a duas células nas listas de adjacência do grafo:
Se os extremos de uma aresta são~$u$ e~$v$, há uma célula com~$u$ na lista de~$v$ e uma célula com~$v$ na lista de~$u$, ambos representando essa aresta.

Pensamos nessas células como representações das duas possíveis orientações da aresta: de~$u$ para~$v$ (algumas vezes denotada por~$uv$) e de~$v$ para~$u$ (algumas vezes denotada por $vu$).
Essas duas células armazenarão o identificador da aresta e terão um apontador $\varname{sym}$, referenciando a outra e vice-versa.
Ademais, cada uma dessas células possuirá também um campo $\varname{orig}$, que identificará o vértice a cuja lista pertence, ou seja, o vértice que é a origem da aresta orientada representada pela célula.

\section{Dualidade}
\label{sec:dualidade}


Dado um grafo plano, o grafo \defi{dual} de~$G$~\cite{Diestel} é o grafo $G^\star = (F,E^\star)$ cujo conjunto de vértices é o conjunto~$F = F(G)$ de faces de~$G$ e o conjunto de arestas $E^\star$ é construído a partir das arestas de~$G$.
Para cada aresta~$e\in E$, existe exatamente uma aresta~$e^\star$ no conjunto $E^\star$.
A aresta~$e^\star$ é chamada de \defi[aresta!dual]{aresta dual} de~$e$ e os vértices incidentes a essa aresta são as duas faces (não necessariamente distintas) cujas fronteiras contém~$e$.
Nesse contexto, chamamos~$G$ de grafo \defi{primal}.
Para ilustrar a relação entre cada aresta e seu dual, geralmente desenhamos cada aresta do grafo dual cruzando a correspondente aresta do grafo primal, como mostra a Figura~\ref{fig:MSF-basico-1}.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-1.tex}
}
\caption{Um grafo ponderado plano e seu dual.}
\label{fig:MSF-basico-1}
\end{figure}


Se~$G$ tem $n$ vértices e~$m$ arestas, o Teorema~\ref{teo:MSFEuler} mostra que o número de vértices do grafo dual é $\OTheta{n+m}$.

\begin{theorem}[\cite{EPPSTEIN-planar}]
\label{teo:MSFdual}
Seja~$T$ uma árvore geradora de um grafo plano conexo~$G$. O conjunto
$$
T^\star = \{e^\star:e\notin T\}
$$
é uma árvore geradora de~$G^\star$.
Além disso, se~$G$ for ponderado e adotarmos $w(e^\star) = w(e)$, então~$T$ será de peso mínimo se e somente se~$T^\star$ for de peso máximo e vice versa.
\end{theorem}

A Figura~\ref{fig:MSF-figura-2} mostra~$T$ e~$T^\star$ do grafo da Figura~\ref{fig:MSF-basico-1}.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-2}
}
\caption{Árvore geradora~$T$ de peso mínimo do grafo da Figura~\ref{fig:MSF-basico-1} e árvore correspondente~$T^\star$ do grafo.}
\label{fig:MSF-figura-2}
\end{figure}



Dado um grafo~$G$, um \defi{corte} é um conjunto de arestas cuja remoção aumenta o conjunto de componentes conexas de~$G$.
Dado $F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$, então existe um corte associado ao par $(F, uv)$ dado pela união de $uv$ com as arestas que reconectam as duas árvores geradas pela remoção de $uv$.


\begin{theorem}
\label{teo:cutset}
Seja~$G$ um grafo planar, $F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$, então o conjunto
$$
(F, uv)^\star := \{e^\star:e\in (F, uv)\}
$$
forma um ciclo em $G^\star$.
\end{theorem}


\section{Definição do problema}
\label{sec:definition-MSF}
O problema da floresta maximal de peso mínimo (MSF) em grafos dinâmicos planos ponderados consiste na busca por uma implementação tão eficiente quanto possível para a seguinte biblioteca:

\begin{itemize}
\item \MSFCreate($n$): Cria e devolve um grafo plano ponderado~$G$ com $n$ vértices isolados.
\item \MSFaddEdge($G$, $e$, $u$, $e_u$, $v$, $e_v$, $w$): Insere em~$G$ uma nova aresta~$e$ com peso~$w$ ligando os vértices~$u$ e~$v$. A nova aresta~$e$ é sucessora das arestas~$e_u$ e~$e_v$ nas ordenações cíclicas de~$u$ e~$v$, respectivamente.
\item \MSFdelEdge($G$, $e$): Remove a aresta~$e$ de~$G$.
\item \MSFupdate($G$, $e$, $w$): Altera o peso da aresta~$e$ do grafo dinâmico~$G$ para o valor~$w$.
\item \MSFweight($G$): Devolve o peso de uma MSF de $G$.
\end{itemize}


\section{Árvores dinâmicas planas}
\label{sec:EODT}

Para resolver o problema da floresta geradora de peso mínimo em grafos dinâmico planos ponderados, Eppstein et al.~\cite{EPPSTEIN-planar} propõem o uso de uma estrutura de dados que chamaremos de \defi[arvore@\'arvore!dinâmica plana]{Árvores dinâmicas planas} (ADP), originalmente os autores nomearam essa estrutura de \textit{edge ordered dynamic tree}.

Seguindo a descrição de Eppstein et al.~\cite[Seção 3]{EPPSTEIN-planar}, essa estrutura consiste de árvores em que cada nó possui um peso, juntamente com uma descrição combinatória plana das árvores.
Como árvores não possuem arestas paralelas, consideraremos que a ordenação cíclica para cada nó~$u$ é uma sequência dos nós vizinhos de~$u$ no ordem anti-horária em vez de arestas.

Árvores dinâmicas planas dão suporte à seguinte biblioteca:
\begin{itemize}
\item \LCOMakeNode(): Cria e retorna um novo nó.
\item \LCOLink($v$, $u$): Adiciona uma aresta ligando os nós~$v$ a~$u$, tornando~$v$ um filho de~$u$.
O nó $w$ é inserido no final de~$D(v)$ e~$v$ no inicio de~$D(w)$.
Essa operação assume que~$v$ é a raiz de sua árvore e que $v$ e $w$ estão em árvores distintas.
\item \LCOMerge($u$, $v$): Recebe dois nós~$u$ e~$v$ de mesmo peso e retorna um único nó~$z$ que é a união desses nós.
Se~$\alpha$ e~$\beta$ são respectivamente as ordenações cíclicas de arestas incidentes a~$u$ e a~$v$ seguindo a descrição combinatória plana, então $\alpha\beta$ é a lista de arestas incidentes a~$z$.
\item \LCOSplit($u$, $e$): Recebe nós adjacentes~$u$ e~$e$.
Substitui o nó~$u$ por dois nós~$v$ e~$z$.
Se a ordem cíclica $D(u)$ tem forma $\alpha e\beta$, então $\alpha e$ e~$\beta$ são as ordens cíclicas de~$v$ e~$w$, respectivamente.
\item \LCOCycle($v$, $e$): Permuta ciclicamente $D(v)$ de forma que o nó $e$ é o último na ordem. Se a ordem inicial tem forma $\alpha e \beta$, então a ordem resultante é $\beta\alpha e$.
\item \LCORoot($v$): Retorna a raiz da árvore do nó~$v$.
\item \LCOAddCost($v$, $w$): Atribui o peso~$w$ ao nó~$v$.
\item \LCOMax($u$, $v$): Retorna o nó de peso máximo no percurso entre os nós~$u$ e~$v$.
\item \LCOMin($u$, $v$): Retorna o nó de peso mínimo no percurso entre os nós~$u$ e~$v$.
\item \LCOConnected($u$, $v$): Retorna verdadeiro se os nós~$u$ e~$v$ estiverem na mesma componente conexa e falso caso contrário.
\end{itemize}

A estrutura também se aplica a grafos planos desconexos, funcionando como a união independente das estruturas correspondentes para cada componente do grafo.

\section{Resolvendo MSF com árvores dinâmicas planas}

Representaremos cada componente conexa~$C$ do grafo dinâmico plano ponderado~$G$ em um plano distinto.
Dessa forma, cada componente possui uma face exterior própria.

Cada componente conexa~$C$ de $G$ é representada por duas ADPs.
Uma delas representa uma árvore geradora de pesos mínimos~$T$ de $C$.
Enquanto que a outra representa sua correspondente dual~$T^\star$.

A primeira árvore, que é denotada por~$\hat T$, é essencialmente a árvore~$T$ submetida a duas transformações: cada uma de suas aresta é subdivida; e é adicionado uma folha a cada vértice incidente a uma aresta de~$C$ que não esteja em~$T$.

Mais precisamente, $\hat T$ possui um nó~$\hat v$ para cada vértice~$v$ de~$C$, um nó~$\hat e$ para cada aresta~$e$ de~$T$ e dois nós~$\hat d_1$ e~$\hat d_3$ para cada aresta~$d^\star$ de~$T^\star$.
O peso do nó~$\hat v$ é $-\infty$, enquanto que os pesos de~$\hat e$, $\hat d_1$ e~$\hat d_3$ são os pesos das arestas representadas por esses nós. 
Se uma aresta $e$ de $T$ é incidente aos vértices~$v$ e~$u$ de~$C$, então $\hat e$ é ligado aos nós~$\hat v$ e~$\hat u$.
Se uma aresta~$d$ de~$C$ não está em $T$ e é incidente aos vértices~$v$ e~$u$ de~$C$, então $\hat d_0$ e $\hat d_2$ são ligado a~$\hat v$ e~$\hat u$, respectivamente.
Note que $\hat d_0$ e $\hat d_2$ não estão ligados, logo são folhas da ADP.

A segunda ADP, denotada por~$\hat T^\star$  possui construção análoga à primeira, mas é baseada em~$T^\star$ ao invés de~$T$.
A ADP possui um nó $\hat F$ para cada vértice~$F$ de~$C^\star$ (isto é, cada face de~$C$), um nó~$\hat e^\star$ para cada aresta~$e^\star$ de $T^\star$ e dois nós $\hat d_1$ e~$\hat d_3$ para cada aresta~$d$ de $T$.
O peso do nó~$\hat F$ é $\infty$, enquanto que os pesos de $\hat e^\star$, $\hat d_1$ e~$\hat d_3$ são os pesos das arestas representadas por esses nós.
Se uma aresta $e^\star$ de $T^\star$ é incidente às faces~$F$ e~$G$ de~$C$, então $\hat e^\star$ é ligado ao nós~$\hat F$ e~$\hat G$.
Se uma aresta $d^\star$ de~$C^\star$ não está em $T^\star$ e é incidente às faces~$F$ e~$G$ de~$C$, então $\hat d_1$ e $\hat d_3$ são ligado a~$\hat F$ e~$\hat G$ respectivamente.
A Figura~\ref{fig:MSF-figura-3} ilustra $\hat T$ e $\hat T^\star$.

\begin{figure}[htb]
%\scalebox{2}{
\centering
\input{fig/MSF-basico-3}
%}
\caption{As árvores geradoras modificadas~$\hat T$ e~$\hat T^\star$ construídas a partir das árvores da Figura~\ref{fig:MSF-figura-2}.}
\label{fig:MSF-figura-3}
\end{figure}
Manteremos essas duas ADPs e duas tabelas de símbolos, $H_v$ e $H_e$. $H_v$ guarda o conjunto de nós que representam vértices e usa como chave os identificadores dos vértices.
$H_e$ guarda informações sobre as arestas de $G$, para cada aresta~$e$ retorna a quadrupla $(\varname{primal}$, $\hat e$, $\hat e_1$, $\hat e_3$), onde $\varname{primal}$ é um booleado que é igual a verdadeiro se~$e$ é uma aresta de $T$ e falso caso contrário. $\hat e$ é o nó que representa $e$ ou $e^\star$ e $\hat e_1$, $\hat e_3$ são as duas folhas associadas a~$e$. 

A primeira rotina de MSF que vamos apresentar é \MSFupdate{}, cuja implementação pode ser vista no Algoritmo~\ref{Algo:MSFupdate}.

Quando atualizamos o peso de uma aresta~$e$ para um novo peso~$w$, precisamos atualizar a árvore geradora de pesos mínimos~$T$ que está sendo mantida de forma que ela continue sendo de peso mínimo.

Se~$e$ for uma aresta de~$T$, é necessário verificar se não há alguma aresta no corte~$(T, e)$ com peso menor do que~$w$, pois se tal aresta existir, então~$T$ e~$T^\star$ não serão mais de peso mínimo e máximo, respectivamente.
Para corrigir isso, seja~$d$ a aresta de menor peso no corte~$(T, e)$,
então $e$ é removida de~$T$ e $e^\star$ adicionada a~$T^\star$ e~$d^\star$ é removida de~$T^\star$ e $d$ é adicionada a~$T$.

Pelo Teorema~\ref{teo:cutset}, o conjunto~$(T, e)^\star$ forma um ciclo em~$C^\star$.
Como~$e^\star \in (T, e)^\star$ e~$e$ é a única aresta de~$T$ cujo dual está em~$(T, e)^\star$, então as demais arestas desse corte formam um caminho em~$T^\star$ ligando os vértices incidentes a~$e^\star$.

Dessa forma, cada aresta $d\in (T, e)$ de menor peso é representada por exatamente um nó nesse percurso que possui peso mínimo nesse percurso em~$\hat T^\star$.
Para obter o nó $\hat d$ de menor peso percorrer esse caminho, usaremos os nós $\hat e_1$ e $\hat e_3$ e a rotina \LCOMin{} da biblioteca de ADPs, isso é feito na linha~\ref{Algo:MSFupdate:linhamin} do Algoritmo~\ref{Algo:MSFupdate}.

As remoções de~$e$ de~$T$ e $d^\star$ de~$T^\star$ são feitas nas linhas~\ref{Algo:MSFupdate:linhasplitd} e~\ref{Algo:MSFupdate:linhasplite} utilizando a rotina~\LCOSplit{}, que converte os nós~$\hat e$ e~$\hat d$ nos nós $\hat d_1$, $\hat d_3$, $\hat e_0$ e~$\hat e_2$, que se tornarão as novas folhas associadas às arestas~$e$ e~$d$.
Para adicionar as arestas~$e^\star$ a~$T^\star$ e $d$ a~$T$ são usados as folhas~$\hat d_0$, $\hat d_2$, $\hat e_1$ e~$\hat e_3$ junto a rotina \LCOMerge{} nas linhas \ref{Algo:MSFupdate:linhas:Merged} e~\ref{Algo:MSFupdate:linhas:Mergee} do Algoritmo~\ref{Algo:MSFupdate}.

Se~$e$ não for uma aresta de~$T$, então teremos que~$e^\star$ é uma aresta de~$T^\star$.
O tratamento desse caso é análogo ao caso anterior e é feito entre as linhas~\ref{Algo:MSFupdate:dualinicio} e~\ref{Algo:MSFupdate:dualfim} do Algoritmo~\ref{Algo:MSFupdate}.

\begin{algorithm}[htb]
\caption{\MSFupdate($G$, $e$, $w$)}
\label{Algo:MSFupdate}
\begin{algorithmic}[1]
\State primal, $\hat e$, $\hat e_1$, $\hat e_3$, $\hat v$, $\hat u$ $\gets$ $H_e$($e$)
\State \LCOAddCost($\hat e$, $w$); \LCOAddCost($\hat e_1$, $w$); \LCOAddCost($\hat e_2$, $w$)
\If {primal}
\State $d$ $\gets$ \LCOMin($\hat e_1$, $\hat e_3$)\label{Algo:MSFupdate:linhamin}

\State primal, $\hat d$, $\hat d_0$, $\hat d_2$, $\hat x$, $\hat y$ $\gets$ $H_e$($d$)
\If {$\hat d$.$w$ < $w$}
\State $\hat d_1$, $\hat d_3$ $\gets$ \LCOSplit($\hat d$, $\hat x$)\label{Algo:MSFupdate:linhasplitd}
\State $\hat e_0$, $\hat e_2$ $\gets$ \LCOSplit($\hat e$, $\hat v$)\label{Algo:MSFupdate:linhasplite}


\State $\hat d$ $\gets$ \LCOMerge( $\hat d_0$, $\hat d_2$)\label{Algo:MSFupdate:linhas:Merged}
\State $\hat e$ $\gets$ \LCOMerge( $\hat e_1$, $\hat e_3$)\label{Algo:MSFupdate:linhas:Mergee}
\State $H(e)$ $\gets$ falso, $\hat e$, $\hat e_0$, $\hat e_2$, $\hat v$, $\hat u$
\State $H(d)$ $\gets$ verdadeiro, $\hat d$, $\hat d_1$, $\hat d_3$, $\hat x$, $\hat y$

\EndIf

\Else
\State $d$ $\gets$ \LCOMax($\hat e_1$, $\hat e_3$)\label{Algo:MSFupdate:dualinicio}

\State primal, $\hat d$, $\hat d_0$, $\hat d_2$, $\hat x$, $\hat y$ $\gets$ $H$($d$)
\If {$\hat d$.$w$ > $w$}
\State $\hat d_1$, $\hat d_3$ $\gets$ \LCOSplit($\hat d$, $\hat x$)
\State $\hat e_0$, $\hat e_2$ $\gets$ \LCOSplit($\hat e$, $\hat v$))

\State $\hat d$ $\gets$ \LCOMerge( $\hat d_0$, $\hat d_2$)
\State $\hat e$ $\gets$ \LCOMerge( $\hat e_1$, $\hat e_3$)

\State $H(e)$ $\gets$ verdadeiro, $\hat e$, $\hat e_0$, $\hat e_2$, $\hat v$, $\hat u$
\State $H(d)$ $\gets$ falso, $\hat d$, $\hat d_1$, $\hat d_3$, $\hat x$, $\hat y$

\EndIf
\EndIf\label{Algo:MSFupdate:dualfim}
\end{algorithmic}
\end{algorithm}


A próxima rotina elaborada é \MSFdelEdge{}, cuja implementação pode ser vista no Algoritmo~\ref{Algo:MSFdelEdge}.

Pelo Lema~\ref{lemma:diestel}, ou uma aresta~$e$ não está em ciclos e as duas faces incidentes a ela são iguais, ou essas faces são distintas e a aresta está em pelo menos um ciclo.

No primeiro caso, a remoção de~$e$ desconecta $C$.
Logo não há trabalho de manutenção em $\hat T$ além de remover~$e$ de~$\hat T$.
A face incidente a aresta~$e$ é a face exterior~$F$.
Como cada componente conexa está imersa em um plano distinto, será necessário dividir $\hat F$ em dois nós, que representarão as duas faces exteriores das duas componentes conexas resultantes da remoção de~$e$.


No segundo caso, a remoção de~$e$ não desconecta $C$.
Dessa forma, é necessário buscar uma substituta para $e$ caso essa aresta seja uma aresta de $T$.
Para fazer essa busca eficientemente, na linha~\ref{Algo:MSFdelEdge:linha:mudaPeso} do Algoritmo~\ref{Algo:MSFdelEdge}, o peso de~$e$ é mudado para~$\infty$, fazendo com que essa aresta se torne uma aresta de~$T^\star$. 
A remoção de $e$ implica na junção das duas faces distintas $F_0$ e $F_2$ incidentes a essa aresta.
Essa mesclagem é feita de forma que a descrição combinatória resultante se mantenha plana, isto é, se $\alpha e^\star \beta$ e $\gamma e^\star \delta$ forem as ordenações de $F_0$ e $F_2$, respectivamente, então $\alpha \delta\gamma\beta$ é a ordenação ciclica da face resultante.

Para implementar essa rotina será necessário incrementar a biblioteca de árvores dinâmicas planas com uma rotina que relacione $\hat T$ com $\hat T^\star$.
A rotina adicional se chama \LCOLeftFace{} e associa os nós que são folhas com nós que representam vértices e faces.

Dada uma orientação de uma aresta~$e$ de~$C$, é possível definir a \defi[face!esquerda]{face esquerda} de uma aresta.\TODO{consultar definição de face esquerda/direita na literatura}

Cada folha pode ser visto como a orientação de uma aresta de $C$ ou $C^\star$.
Assim possuindo uma face a esquerda bem definida.

\begin{itemize}
\item \LCOLeftFace($e$): Recebe um nó folha e retorna o nó que representa a face a esquerda dessa folha.
\end{itemize}

A primeira coisa feita é mudar o peso de $e$ para $\infty$, assim tornando-a uma aresta de~$\hat T^\star$.
Dessa forma, as duas folhas~$\hat e_0$ e~$\hat e_2$ são nós de~$\hat T$.

Em seguida, a nova rotina \LCOLeftFace{} é usada para obter os dois nós que representam as faces incidentes à aresta $e$.


\begin{algorithm}[htb]
\caption{\MSFdelEdge($G$, $e$)}
\label{Algo:MSFdelEdge}
\begin{algorithmic}[1]
\State \MSFupdate($G$, $e$, $\infty$)\label{Algo:MSFdelEdge:linha:mudaPeso}
\State \varname{primal}, $\hat e$, $\hat e_0$, $\hat e_2$, $\hat u$, $\hat v$ $\gets$ $H_e(e)$
\State $\hat F_0$ $\gets$ \LCOLeftFace($\hat e_0$)
\State $\hat F_2$ $\gets$ \LCOLeftFace($\hat e_2$)
\State
\State \LCOCycle($\hat u$, $\hat e_0$)
\State \LCOSplit($\hat u$, \LCOPredecessor($\hat u$, $\hat e_0$))
\State \LCOCycle($\hat v$, $\hat e_2$)
\State \LCOSplit($\hat v$, \LCOPredecessor($\hat v$, $\hat e_2$))
\State
\State \LCOCycle($\hat F_0$, $\hat e$)
\State \LCOSplit($\hat F_0$, \LCOPredecessor($\hat F_0$, $\hat e$))
\State \LCOCycle($\hat F_2$, $\hat e$)
\State \LCOSplit($\hat F_2$, \LCOPredecessor($\hat F_2$, $\hat e$))
\State
\State \LCOMerge($\hat F_0$, $\hat F_2$)
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[htb]
\caption{\MSFaddEdge($G$, $e$, $u$, $e_u$, $v$, $e_v$, $w$)}
\label{Algo:MSFaddEdge}
\begin{algorithmic}[1]

\State $\hat u$ $\gets$ $H_v(u)$; $\hat v$ $\gets$ $H_v(v)$
\State $\varname{primal}_u$, $\hat e_u$, $\hat e_{u0}$, $\hat e_{u2}$, $\hat u$, $\hat x$ $\gets$ $H_e(e_u)$
\State $\varname{primal}_v$, $\hat e_v$, $\hat e_{v0}$, $\hat e_{v2}$, $\hat v$, $\hat y$ $\gets$ $H_e(e_v)$
\For {$i \in \{0,1,2,3\}$}
\State $\hat s_i$ $\gets$ \LCOMakeNode(); $\hat e_i$ $\gets$ \LCOMakeNode()
\State  \LCOAddCost($\hat e_i$, $w$);
\State \LCOLink($\hat e_i$, $\hat s_i$)
\EndFor
\State \LCOAddCost($\hat s_0$, $-\infty$); \LCOAddCost($\hat s_2$, $-\infty$);
\State \LCOAddCost($\hat s_1$, $\infty$); \LCOAddCost($\hat s_3$, $\infty$);

\If{\LCOConnected($\hat u$, $\hat v$)}



\Else
\If{$\varname{primal}_u$}
\State \LCOCycle($\hat u$, $\hat e_u$)
\Else
\State \LCOCycle($\hat u$, $\hat e_{u0}$)
\EndIf
\State \LCOMerge($\hat u$, $\hat s_0$)
\State \LCOMerge($\hat v$, $\hat s_v$)
\State \LCOCycle($\hat u$, $\hat e_u$)
\State \MSFupdate($G$, $e$, $w$)
\EndIf
\end{algorithmic}
\end{algorithm}



\section{Estruturas auxiliares}
\subsection{Árvores binárias de busca com chave implícita}
\subsection{Link-Cut Trees}
\label{sec:linkcuttree}

Para uma introdução sobre link-cut trees, recomendamos o trabalho de~\cite{linkcuttree}.

\begin{itemize}
\item \linkcutCreate(): Cria e retorna um novo nó de link-cut tree.
\item \linkcutAddEdge($v$, $w$): Adiciona uma aresta de~$v$ a~$w$, tornando~$v$ um filho de~$w$. Essa operação assume que~$v$ é a raiz de uma árvore~$T$ e que $w$ não é um nó de~$T$.
\item \linkcutDelEdge($v$): Remove a aresta de~$v$ para seu pai.
\item \linkcutEvert($v$): Torna~$v$ a raiz de sua árvore revertendo o caminho de~$v$ para a raiz original.
\item \linkcutMax($v$): Retorna o nó de peso máximo no caminho entre~$v$ e a raiz de sua árvore.
\item \linkcutMin($v$): Retorna o nó de peso mínimo no caminho entre~$v$ e a raiz de sua árvore.
\end{itemize}


\section{Implementação de árvores dinâmicas planas}

Além dessas rotinas, as árvores dinâmicas planas que implementaremos usaram duas rotinas internas.

\begin{itemize}
\item \LCOFindNode($s$): Recebe um sub-nó $s$ e retorna o nó que contêm $s$ em seu \textit{node path}.
\item \LCOFindSubNode($\hat v$, $\hat e$): Recebe dois nós e retorna o subnó $s$ e retorna o nó que contêm $s$ em seu \textit{node path}.
\end{itemize}





\begin{algorithm}[htb]
\caption{\LCOFindSubNode($\hat v$, $\hat e$)}
\label{Algo:LCOFindSubNode}
\begin{algorithmic}[1]
\If{ $e$ $\in$ $T$}
\State $v_{first}$, $v_{last}$ $\gets$ $\hat v$
\State $e_{first}$, $e_{last}$ $\gets$ $\hat e$
\State \linkcutEvert($v_{first}$)
\If{$e_{first}$.$parent$ $\neq$ $e_{last}$}
\State \Return $e_{first}$.$parent$
\EndIf
\State \Return $e_{last}$.$parent$
\Else
\If { \LCOFindNode($e_{first}.rot.parent$) $=$ $v$  }\Comment{$e_{first}$ e $e_{last}$ apontam pra $T^\star$}
\State \Return $e_{first}.rot.parent$
\Else
\State \Return $e_{last}.rot.parent$
\EndIf
\EndIf
\end{algorithmic}
\end{algorithm}



\begin{algorithm}[htb]
\caption{\LCOFindNode($s$)}
\label{Algo:LCOFindNode}
\begin{algorithmic}[1]
\State $r$ $\gets$ \treapGetRoot($s$)
\State \Return $r$.$\node$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[htb]
\caption{\LCOMerge($\hat u$, $\hat v$)}
\label{Algo:LCOMerge}
\begin{algorithmic}[1]
\State $\hat w$ $\gets$ \LCOMakeNode()
\State \linkcutEvert($\hat u$.$last$)
\State \linkcutAddEdge($\hat u$.$last$, $\hat v$.$first$)
\State $\hat w$.$first$  $\gets$ $\hat u$.$first$
\State $\hat w$.$last$  $\gets$ $\hat v$.$last$
\State $T$ $\gets$ \treapJoin(\treapGetRoot($\hat u$.$first$), \treapGetRoot($\hat v$.$last$))
\State $T$.$\node$ $\gets$ $\hat w$
\State \Return $\hat w$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[htb]
\caption{\LCOSplit($\hat u$, $\hat e$)}
\label{Algo:LCOSplit}
\begin{algorithmic}[1]
\State $s_e$ $\gets$ \LCOFindSubNode($\hat u$, $\hat e$)
\State $\hat v$ $\gets$ \LCOMakeNode()
\State $\hat w$ $\gets$ \LCOMakeNode()
\State \linkcutEvert($\hat u$.$last$)
\State $y$ $\gets$ \linkcutParent($s_e$)
\State \linkcutDelEdge($s_e$)
\State $T$, $u_{last}$, $T'$ $\gets$ \treapSplit($\hat u$.$last$)
\State $T$ $\gets$ \treapJoin($T$, $u_{last}$)
\State $T$.$\node$ $\hat w$
\State $T'$.$\node$ $\hat v$
\State $\hat v$.$first$ $\gets$ $\hat u$.$first$; $\hat v$.$last$ $\gets$ $s_e$
\State $\hat w$.$first$ $\gets$ $y$; $\hat w$.$last$ $\gets$ $u_{last}$
\State \Return $\hat v$, $\hat w$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[htb]
\caption{\LCOCycle($\hat v$, $\hat e$)}
\label{Algo:LCOCycle}
\begin{algorithmic}[1]
\State $s_e$ $\gets$ \LCOFindSubNode($\hat v$, $\hat e$)
\State \linkcutEvert($\hat v$.$last$)
\If{$\hat v$.$last$ $=$ $s_e$}
\State\Return
\EndIf
\State $x$ $\gets$ \linkcutParent($s_e$)
\State \linkcutDelEdge($s_e$)
\State \linkcutAddEdge($\hat v$.$last$, $\hat v$.$first$)
\State $\hat v$.$first$ $\gets$ $x$; $\hat v$.$last$ $\gets$ $s_e$
\State $T$, $u_{last}$, $T'$ $\gets$ \treapSplit($\hat u$.$last$)
\State $T$ $\gets$ \treapJoin($T'$, $T$, $u_{last}$)
\State $T$.$\node$ $\hat v$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[htb]
\caption{\LCOLink($\hat v$, $\hat w$)}
\label{Algo:LCOLink}
\begin{algorithmic}[1]
\State $x$ $\gets$ \linkcutCreate()
\State $y$ $\gets$ \linkcutCreate()
\If {$\hat v$.$last$ $=$ $\Nil$}
  \State $T$ $\gets$ \treapCreate()
  \State $T$.$\node$ $\gets$ $\hat v$
  \State $\hat v$.$first$ $\gets$ $x$; $\hat v$.$last$ $\gets$ $x$ 
\Else
  \State \linkcutEvert($\hat v$.$last$)
  \State \linkcutAddEdge($\hat v$.$last$, $x$)
  \State $T$ $\gets$ \treapGetRoot($\hat v$.$last$)
  \State $T$ $\gets$ \treapJoin($T$, $x$)
  \State $T$.$\node$ $\gets$ $\hat v$
  \State $\hat v$.$last$ $\gets$ $x$
\EndIf
\If {$\hat w$.$last$ $=$ $\Nil$}
  \State $T$ $\gets$ \treapCreate()
  \State $T$.$\node$ $\gets$ $\hat w$
  \State $\hat w$.$first$ $\gets$ $y$; $\hat w$.$last$ $\gets$ $y$ 
\Else
  \State \linkcutAddEdge($y$, $\hat w$.$first$)
  \State $T$ $\gets$ \treapGetRoot($\hat w$.$last$)
  \State $T$ $\gets$ \treapJoin($y$, $T$)
  \State $T$.$\node$ $\gets$ $\hat w$
  \State $\hat w$.$first$ $\gets$ $y$
\EndIf
\State \linkcutAddEdge($x$, $y$)
\end{algorithmic}
\end{algorithm}


\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-4}
}
\caption{As árvores geradoras modificadas que representam o grafo da Figura~\ref{fig:MSF-basico-1}.}
\label{fig:MSF-figura-4}
\end{figure}
