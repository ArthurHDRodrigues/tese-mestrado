\chapter{Floresta maximal de peso mínimo em grafos planos}
\label{sec:MSF}

O problema da floresta maximal de peso mínimo em grafos dinâmicos planos foi inicialmente apresentado na Seção~\ref{sec:Motivação} e é o segundo problema que iremos discutir.
O objetivo desse capítulo é apresentar o algoritmo de David Eppstein, Giuseppe Italiano, Roberto Tamassia, Robert Tarjan, Jeffery Westbrook e Moti Yung~\cite{EPPSTEIN-planar} que resolve esse problema para grafos planos que podem ter laços e arestas paralelas.

O estudo desse problema se inicia com uma revisão de conceitos de planaridade e dualidade apresentados nas Seções~\ref{sec:planaridade} e~\ref{sec:dualidade} respectivamente.
Esses conceitos são bem estabelecidos na literatura e essas seções são baseadas na Seção~4.2 do livro \textit{Graph Theory} de Reinhard Diestel~\cite{Diestel}.

Os conceitos apresentando nessas duas seções iniciais serão usados para definir formalmente o problema, o que é feito na Seção~\ref{sec:definition-MSF}, e para fundamentar a estrutura de dados que resolve esse problema, que será apresentada na Seção~\ref{sec:EODT}.

\section{Planaridade}
\label{sec:planaridade}

Intuitivamente, um grafo é dito plano se ele está desenhado em uma folha de papel de forma que suas arestas não se cruzem.
Formalmente, um \defi[grafo!plano]{grafo plano}~\cite{Diestel} é um par de conjuntos finitos $G = (V, E)$ com as seguintes propriedades:
\begin{enumerate}
\item $V\subset \R^2$;
\item Toda aresta é um arco entre dois vértices;
\item O interior de uma aresta não contém vértices nem intersecta outras arestas.
\end{enumerate}
Quando conveniente, $G$ será usado tanto para o par~$(V ,E)$ quanto para o conjunto~${V\cup\bigcup E}$.

Para cada grafo plano~$G$, ao remover~$G$ do plano~$\R^2$, é obtido um conjunto finito~$F(G)$ de regiões conexas que é chamado de \defi{conjunto de faces} de~$G$.
Naturalmente, cada uma dessas regiões é chamada de uma \defi{face} de $G$.
Uma dessas faces é ilimitada.
Essa face é chamada de \defi{face exterior}.
A Figura~\ref{fig:MSF-basico-0} mostra um grafo plano~$G$ e suas as faces.

\begin{minipage}[b]{0.4\textwidth}
\centering
\begin{tabular}{| c  c |} 
 \hline
 aresta & peso\\
 \hline
 $a$ & 2 \\ 
 \hline
$b$ & 7 \\
 \hline
$c$ & 3 \\
 \hline
$d$ & 1 \\
 \hline
$f$ & 2 \\
 \hline
$g$ & 4 \\
 \hline
\end{tabular}
\captionof{table}{Tabela de pesos}
\end{minipage}
\hfill
\begin{minipage}[b]{0.6\textwidth}
\scalebox{1.5}{
  \centering
  \input{fig/MSF-basico-0.tex}
  }
  \captionof{figure}{Um grafo ponderado plano e suas faces.}
 \label{fig:MSF-basico-0}
\end{minipage}

\begin{lemma}[Lemma 4.2.2~\cite{Diestel}]
\label{lemma:diestel}
Seja $G$ um grafo plano e $e$ uma de suas arestas.
\begin{enumerate}
\item Se $X$ é a fronteira de uma face de~$G$, então ou $e\subseteq X$ ou a intersecção de $X$ com o interior de $e$ é vazia.
\item Se $e$ pertence a um ciclo de $G$, então $e$ pertence à fronteira de exatamente duas faces distintas de $G$;
\item Se não existe ciclo que contém $e$, então $e$ pertence à fronteira de uma única face de~$G$.
\end{enumerate}
\end{lemma}

Para cada vértice $v$ de um grafo plano~$G$, é possível construir uma ordenação cíclica~$D(v)$ das aresta incidentes a~$v$~\cite{noma2003}.
Para obter essa ordenação, percorremos as arestas incidentes a~$v$ em sentido anti-horário até retornar à aresta inicial do percurso.
Uma aresta é dita \defi{sucessora} de outra aresta se a primeira é sucessora da segunda nesse percurso.
Uma lista de todas essas ordens cíclicas é chamada de~\defi{descrição combinatória plana} de~$G$.

A descrição combinatória plana é essencialmente uma lista de adjacências do grafo plano em que a ordem das células é relevante.
Para o algoritmo que vamos descrever nesse capítulo, cada aresta possui um identificador e armazenamos também nas células das listas o identificador das arestas.
Observe que cada aresta corresponde a duas células nas listas de adjacência do grafo:
Se os extremos de uma aresta são~$u$ e~$v$, há uma célula com~$u$ na lista de~$v$ e uma célula com~$v$ na lista de~$u$, ambos representando essa aresta.
Como estamos admitindo arestas paralelas, o número de ocorrências de um vértice~$u$ na lista de um vértice~$v$ será exatamente o número de arestas paralelas entre~$u$ e~$v$.
Um laço num vértice~$u$ corresponderá a duas ocorrências de~$u$ na sua lista de adjacências.
Abaixo temos uma descrição combinatória plana do grafo da Figura~\ref{fig:MSF-basico-0}.
\begin{align*}
D(u)&=\langle (a,v), (b,v), (c,z))\rangle\\
D(v)&=\langle (a,u), (d,z), (b,u)  \rangle\\
D(y)&=\langle (e,z), (f,y), (f,y) \rangle
\end{align*}

Pensamos nessas células como representações das duas possíveis orientações da aresta: de~$u$ para~$v$ (algumas vezes denotada por~$uv$) e de~$v$ para~$u$ (algumas vezes denotada por $vu$).
Essas duas células terão também um apontador~$\varname{sym}$, referenciando à outra e vice-versa.
%Ademais, cada uma dessas células possuirá também um campo $\varname{orig}$, que identificará o vértice a cuja lista pertence, ou seja, o vértice que é a origem da aresta orientada representada pela célula.

\section{Dualidade}
\label{sec:dualidade}


Dado um grafo plano~$G$, o grafo \defi{dual} de~$G$~\cite{Diestel} é o grafo $G^\star = (F,E^\star)$ cujo conjunto de vértices é o conjunto~$F = F(G)$ de faces de~$G$ e o conjunto de arestas $E^\star$ é construído a partir das arestas de~$G$.
Para cada aresta~$e\in E$, existe exatamente uma aresta~$e^\star$ no conjunto $E^\star$.
A aresta~$e^\star$ é chamada de \defi[aresta!dual]{aresta dual} de~$e$ e os vértices incidentes a essa aresta são as duas faces (não necessariamente distintas) cujas fronteiras contém~$e$.
Nesse contexto, chamamos~$G$ de grafo \defi{primal}.
O grafo dual também é um grafo plano.
Para ilustrar a relação entre cada aresta e seu dual, geralmente desenhamos cada aresta do grafo dual cruzando a correspondente aresta do grafo primal, como mostra a Figura~\ref{fig:MSF-basico-1}.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-1.tex}
}
\caption{Um grafo ponderado plano e seu dual.}
\label{fig:MSF-basico-1}
\end{figure}

\begin{theorem}[Fórmula de Euler, Teorema 4.2.9~\cite{Diestel}]
\label{teo:MSFEuler}
Seja $G=(V,E)$ um grafo planar conexo com~$n$ vértices e~$m$ arestas. Toda imersão de~$G$ no plano possui o mesmo número $f$ de faces e
$$
n-m+f = 2.
$$
\end{theorem}

Se~$G$ é um grafo plano com~$n$ vértices e~$m$ arestas, o Teorema~\ref{teo:MSFEuler} mostra que o número de vértices do seu grafo dual é $\OTheta{n+m}$.

\begin{theorem}[\cite{EPPSTEIN-planar}]
\label{teo:MSFdual}
Seja~$T$ uma árvore geradora de um grafo plano conexo~$G$. O conjunto
$$
T^\star = \{e^\star:e\notin T\}
$$
é uma árvore geradora de~$G^\star$.
Além disso, se~$G$ for ponderado e adotarmos $w(e^\star) = w(e)$, então~$T$ será de peso mínimo em~$G$ se e somente se~$T^\star$ for de peso máximo em~$G^\star$ e vice versa.
\end{theorem}

A Figura~\ref{fig:MSF-figura-2} mostra~$T$ e~$T^\star$ dos grafos da Figura~\ref{fig:MSF-basico-1}.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-2}
}
\caption{Árvore geradora~$T$, em azul, de peso mínimo do grafo ponderado da Figura~\ref{fig:MSF-basico-1} e a árvore correspondente~$T^\star$ do seu grafo dual, em vermelho.}
\label{fig:MSF-figura-2}
\end{figure}





\section{Definição do problema}
\label{sec:definition-MSF}
O problema da floresta maximal de peso mínimo (MSF) em grafos dinâmicos planos ponderados consiste na busca por uma implementação tão eficiente quanto possível para a seguinte biblioteca:

\begin{itemize}
\item \MSFCreate($n$): Cria e devolve um grafo plano ponderado~$G$ com $n$ vértices isolados.
\item \MSFaddEdge($G$, $e$, $u$, $e_u$, $v$, $e_v$, $w$): Insere em~$G$ uma nova aresta~$e$ com peso~$w$ ligando os vértices~$u$ e~$v$. A nova aresta~$e$ é sucessora das arestas~$e_u$ e~$e_v$ nas ordenações cíclicas de~$u$ e~$v$, respectivamente.
\item \MSFdelEdge($G$, $e$): Remove a aresta~$e$ de~$G$.
\item \MSFupdate($G$, $e$, $w$): Altera o peso da aresta~$e$ de~$G$ para o valor~$w$.
\item \MSFweight($G$): Devolve o peso de uma MSF de $G$.
\end{itemize}


\section{Árvores dinâmicas planas}
\label{sec:MSFcomADP}

Para resolver o problema da floresta geradora de peso mínimo em grafos dinâmicos planos ponderados, Eppstein et al.~\cite{EPPSTEIN-planar} propuseram o uso de uma estrutura de dados que chamaremos de \defi[arvore@\'arvore!dinâmica plana]{árvores dinâmicas planas} (ADP). Originalmente os autores denominaram essa estrutura de \textit{edge ordered dynamic tree}.

%Seguindo a descrição de Eppstein et al.~\cite[Seção 3]{EPPSTEIN-planar}, essa estrutura consiste de árvores em que cada nó possui um peso, juntamente com uma descrição combinatória plana das árvores.
%Como árvores não possuem arestas paralelas, consideraremos, nas descrições abaixo, que a ordenação cíclica para cada nó~$u$ é simplesmente uma sequência dos nós vizinhos de~$u$ no sentido anti-horário.

Antes de descrever a biblioteca fornecida por ADPs, essa estrutura será detalhada nos próximos parágrafos junto a uma explicação de como utilizá-la para resolver o problema MSF.

Cada componente conexa do grafo plano dinâmico ponderado~$G$ é representada em um plano distinto.
Consequentemente, a face exterior de cada componente conexa é considerada distinta das faces exteriores das outras componentes.
Cada componente~$C$ de~$G$ é representada por duas árvores com pesos em seus \textit{vértices}, sendo a primeira construída a partir de uma árvore geradora de peso mínimo~$T$ de~$C$ e a segunda a partir da correspondente dual~$T^\star$.
A Figura~\ref{fig:MSF-figura-3} ilustra essas duas árvores cuja construção será detalhada no próximo parágrafo.

A primeira dessas árvores, que é denotada por~$\hat T$, é essencialmente a árvore~$T$ submetida a duas transformações:
cada uma de suas arestas é subdivida; e é adicionada uma folha a cada vértice incidente a uma aresta de~$C$ que não esteja em~$T$.
Mais precisamente, $\hat T$ possui um vértice~$\hat v$, de peso~$-\infty$, para cada vértice~$v$ de~$C$, um vértice~$\hat e$, com o peso de $e$, para cada aresta~$e$ de~$T$ e dois vértices~$\hat d_0$ e~$\hat d_2$, ambos com o peso de~$d$, para cada aresta~$d$ tal que $d^\star$ está em~$T^\star$.
Se uma aresta~$e$ de~$T$ é incidente aos vértices~$v$ e~$u$ de~$C$, então o vértice~$\hat e$ é ligado aos vértices~$\hat v$ e~$\hat u$.
Se uma aresta~$d$ de~$C$ não está em~$T$ e é incidente aos vértices~$v$ e~$u$ de~$C$, então~$\hat d_0$ e~$\hat d_2$ são ligados a~$\hat v$ e~$\hat u$, respectivamente.
Note que~$\hat d_0$ e~$\hat d_2$ são folhas da árvore~$\hat T$.
Veja a árvore azul da Figura~\ref{fig:MSF-figura-3} 

A segunda árvore, denotada por~$\hat T^\star$, possui construção análoga à primeira, mas é baseada em~$T^\star$ em vez de~$T$.
Ela possui um vértice~$\hat F$ para cada vértice~$F$ de~$C^\star$ (isto é, para cada face de~$C$), um vértice~$\hat e^\star$ para cada aresta~$e^\star$ de $T^\star$ e dois vértices $\hat d_1$ e~$\hat d_3$ para cada aresta~$d$ de $T$.
O peso do vértice~$\hat F$ é $\infty$, enquanto que o peso de~$\hat e^\star$ é o peso de~$e$ e o peso de~$\hat d_1$ e~$\hat d_3$ é o peso de~$d$.
Se uma aresta $e^\star$ de $T^\star$ é incidente às faces~$F_1$ e~$F_2$ de~$C$, então o vértice~$\hat e^\star$ é ligado aos vértices~$\hat F_1$ e~$\hat F_2$.
Se uma aresta $d^\star$ de~$C^\star$ não está em $T^\star$ e é incidente às faces~$F_1$ e~$F_2$ de~$C$, então $\hat d_1$ e $\hat d_3$ são ligados a~$\hat F_1$ e~$\hat F_2$ respectivamente.
Veja a árvore vermelha na Figura~\ref{fig:MSF-figura-3}.

Note que há uma correspondência entre as arestas incidentes a um vértice~$v$ de~$G$ e os vértices vizinhos de~$\hat v$ em~$\hat T$.
Cada aresta~$e$ de $G$ corresponde a $\hat e$, $\hat e_0$ ou~$\hat e_2$. 
A descrição combinatória plana dessas duas árvores é herdada de~$C$ (ou seja, de~$G$) e de~$C^\star$.



\begin{minipage}[b]{0.4\textwidth}
\centering
\begin{tabular}{| c  c |} 
 \hline
 vértices & pesos\\
 \hline
 $\hat a$, $\hat a_1$, $\hat a_3$ & 2 \\ 
 \hline
 $\hat b$, $\hat b_0$, $\hat b_2$ & 7 \\
 \hline
 $\hat c$, $\hat c_0$, $\hat c_2$ & 3 \\
 \hline
 $\hat d$, $\hat d_0$, $\hat d_2$ & 2 \\
 \hline
 $\hat f$, $\hat f_1$, $\hat f_3$ & 1 \\
 \hline
 $\hat g$, $\hat g_1$, $\hat g_3$ & 4 \\
 \hline
 $\hat u$, $\hat v$, $\hat z$ & $-\infty$ \\
 \hline
 $\hat F_0$, $\hat F_1$, $\hat F_2$, $\hat F_3$ & $\infty$ \\
 \hline
\end{tabular}
\captionof{table}{Tabela de pesos}
\end{minipage}
\hfill
\begin{minipage}[b]{0.5\textwidth}
    \centering
\input{fig/MSF-basico-3}
\label{fig:MSF-figura-3}
	\captionof{figure}{As árvores~$\hat T$ e~$\hat T^\star$ construídas a partir das árvores da Figura~\ref{fig:MSF-figura-2}.}
    \end{minipage}

A implementação de árvores dinâmicas planas utiliza link cut trees e árvores binárias de busca com chave implícita.

Cada vértice~$\hat v$ de~$\hat T$ e~$\hat T^\star$ é implementado por um conjunto de nós de link cut trees.
Esse conjunto possui um nó~$e_v$ para cada aresta~$e$ na ordem cíclica de~$\hat v$.
Cada nó $e_v$ é ligado aos nós que representam a aresta sucessora e predecessora de~$e$ na ordem cíclica de~$\hat v$,
com exceção de~$e_1$ e~$e_k$, que são ligados somente ao seu sucessor e predecessor, respectivamente.
Dessa forma, a ordem cíclica é representada por um caminho na link cut tree.
Além disso, se a aresta~$e$ liga os nós~$\hat v$ e~$\hat u$, então~$e_v$ é ligado ao nó~$e_u$ que representa~$e$ na ordem cíclica de~$\hat u$.

\begin{figure}[htb]
\scalebox{1.3}{
\centering
\input{fig/MSF-basico-4}
}
\caption{Link cut trees que implementam $\hat T$ e $\hat T^\star$ ilustradas na Figura~\ref{fig:MSF-figura-3}.}
\label{fig:MSF-figura-4}
\end{figure}

Cada aresta~$e$ de~$G$, que liga vértices~$u$ e~$v$ e cuja dual $e^\star$ liga vértices~$F_1$ e $F_2$ de~$G^\star$, é implementada por oito nós de link cut tree.
Os quatro primeiros, denotados por~$e_0$, $e_1$, $e_2$ e~$e_3$, representam~$e$.
Os nós $e_0$, $e_2$ são nós de~$\hat T$, enquanto que $e_1$, $e_3$ são nós de~$\hat T^\star$.
Os nós $e_0$ e $e_2$ representam as orientações~$uv$ e~$vu$ de~$e$.
Nesse caso se $F_1$ é a face à esquerda de~$e$ quando vamos de~$u$ para~$v$, o nó $e_1$ representa a orientação $F_1F_2$ de~$e^\star$ enquanto que $e_3$ representa a orientação $F_2F_1$ de~$e^\star$.
Como pode ser visto na Figura~\ref{fig:MSF-figura-4}.

Os quatro últimos nós que representam~$e$ na link cut tree são~$e_u$, $e_v$, ${e^\star}_{F_1}$ e~${e^\star}_{F_2}$, que mantém a posição de~$e$ e~$e^\star$ nas ordens cíclicas $u$, $v$, $F_1$ e $F_2$, respectivamente.
À frente, nos referiremos à óctupla $( e_0, e_1, e_2, e_3, e_u, e_v, {e^\star}_{F_1}, {e^\star}_{F_2})$ como a \defi[octupla]{óctupla} de~$e$.
A Figura~\ref{fig:MSF-octo} ilustra a óctupla das arestas~$b$ e $g$.


\begin{figure}[htb]
\centering
\input{fig/MSF-octo}
\caption{Óctuplas das arestas~$b$ e~$g$.}
\label{fig:MSF-octo}
\end{figure}

Caso~$e$ seja uma aresta de~$T$, então o vértice~$\hat e$ de $\hat T$ é implementado pelos nós~$e_0$,~$e_2$ e a aresta entre eles.
Já os nós $e_1$, $e_3$ individualmente formam as duas folhas $\hat e_1$, $\hat e_3$ de $\hat T^\star$.
Caso~$d$ seja uma aresta de~$T^\star$, então o vértice~$\hat d$ de $\hat T^\star$ é implementado pelos nós~$d_1$,~$d_3$ e a aresta entre eles.
Já os nós $d_0$, $d_2$ individualmente formam as duas folhas $\hat d_0$, $\hat d_2$ de $\hat T$.

Ademais, a sequência~$D(\hat v)$ dos nós de link cut tree que representam as arestas de~$G$ incidentes a~$v$ é armazenada em uma árvore binária de busca com chave implícita.
A ABB é utilizada para obter o primeiro e o último nó da ordem cíclica, o predecessor de um dado nó e identificar se dois nós estão na mesma ordem cíclica.
A raiz dessa ABB possui um campo $\node$ que armazena o identificador $v$.

Manteremos as duas ADPs de $T$ e~$T^\star$ e uma tabela de símbolos~$H$, que guarda óctuplas de cada aresta e usa como chave o identificador da aresta de~$G$.

%Cada nó~$v_i$ é ligado ao nó~$e_i$.

Dessa forma, $G$ e uma floresta geradora maximal~$F$ de~$G$ de peso mínimo é representada por dois conjuntos de ADPs: o conjunto~$\hat F$ das ADPs das componentes de~$F$ e o conjunto~$\hat F^\star$ das ADPs do dual de cada componente de~$F$.

Antes de apresentar a biblioteca de ADPs, na próxima seção, vamos expandir a biblioteca de árvores binárias de busca com chave implícita, que foi inicialmente discutida no Capítulo~\ref{sec:TreapDeChaveImplicita} e apresentar a biblioteca das link cut trees.


\section{Biblioteca de árvores dinâmicas planas}
\label{sec:EODT}

Árvores dinâmicas planas dão suporte à biblioteca listada a seguir.
Para as descrições que se seguem, considere~$u$ e~$v$ vértices da árvore representada,
$p$ um nó da ordem cíclica~$D(u)$ e~$q$ um nó de~$D(v)$.

\begin{itemize}
\item \LCOMakeOcto($e$): Recebe um identificador e cria e retorna uma óctupla de nós de ADP associados a~$e$.
\item \LCODestroyOcto($H$, $e$): Recebe uma tabela de símbolos~$H$ e um identificador~$e$ e desaloca a óctupla associada a~$e$ da memória.

\item \LCOConnected($p$, $q$): Retorna verdadeiro se os nós~$p$ e~$q$ estiverem na mesma ADP e falso caso contrário.
\item \LCOFindNode($p$): Recebe um nó $p$ e retorna o vértice da~$\hat F$ que contêm $p$ em sua ordem cíclica.

Por exemplo: \LCOFindNode($a_u$) retorna $\hat u$, enquanto que \LCOFindNode($b_{F_1}$) retorna $\hat b_{F_1}$.
\item \LCOAddCost($p$, $w$): Atribui o peso~$w$ ao vértice que contém $p$ em sua ordem cíclica.
\item \LCOMax($p$, $q$): Retorna o nó de peso máximo no percurso entre os nós~$p$ e~$q$.
Essa operação assume que $p$ e~$q$ são nós da mesma ADP.
\item \LCOMin($p$, $q$): Retorna o nó de peso mínimo no percurso entre os nós~$p$ e~$q$.
Essa operação assume que~$p$ e~$q$ são nós da mesma ADP.
\item \LCOCycle($p$): Permuta ciclicamente $D(u)$ de forma que o nó~$p$ seja o último na ordem.
Se a ordem inicial tem forma $\alpha p \beta$, então a ordem resultante é $\beta\alpha p$.
\end{itemize}

É possível unir e separar nós das ADPs com as rotinas \LCOMerge{} e \LCOSplit{}.

\begin{itemize}
\item \LCOMerge($p$, $q$, $z$): Recebe dois nós~$p$ e~$q$ de mesmo peso e une os vértices $u$ e $v$ que possuem $p$ e $q$ em suas ordens cíclicas.
Se~$\alpha$ e~$\beta$ são respectivamente as ordens cíclicas de~$u$ e~$v$, então $\alpha\beta$ será a ordem cíclica do vértice resultante~$z$. 
Essa operação assume que~$u$ e~$v$ estão em ADPs distintas.

\item \LCOSplit($p$, $v$, $z$): Substitui o vértice~$u$ por dois vértices~$v$ e~$z$.
Considerando que a ordem cíclica $D(u)$ tem forma $\alpha p\beta$, então $\alpha$ e~$p\beta$ serão as ordens cíclicas de~$v$ e~$z$, respectivamente.

\begin{figure}[htb]
\scalebox{1}{
\centering
\input{fig/MSF-Merge-Split}
}
\caption{Efeito de \LCOMerge{} e \LCOSplit{}.}
\label{fig:MSF-Merge-Split}
\end{figure}


\end{itemize}


A implementação dessas rotinas será apresentada na Seção~\ref{sec:implementacao-ADP}.


\section{Resolvendo MSF com ADPs}

\subsection{Mudança de peso}
A primeira rotina de MSF que vamos apresentar é \MSFupdate{}, cuja implementação pode ser vista no Algoritmo~\ref{Algo:MSFupdate}.
Encorajamos a leitora ou o leitor a acompanhar a explicação do funcionamento dessa rotina antes de ler o pseudocódigo linha-a-linha.
Essa explicação é feita logo após o pseudocódigo e detalha o embasamento teórico utilizado pelo algoritmo, seu funcionamento e ilustra a execução de \MSFupdate($G$, $a$, $5$) como exemplo, onde $G$ é o grafo da Figura~\ref{fig:MSF-figura-4}.


\begin{algorithm}[htb]
\caption{\MSFupdate($G$, $e$, $w$)}
\label{Algo:MSFupdate}
\begin{algorithmic}[1]
\State $e_0$, $e_1$, $e_2$, $e_3$, $v_0$, $v_1$, $v_2$, $v_3$ $\gets$ $H(e)$
\For {$i \in \{0,1,2,3\}$}
\State  \LCOAddCost($e_i$, $w$)
\EndFor

\If {\LCOFindNode($e_0$) $=$ \LCOFindNode($e_2$)}\label{Algo:MSFupdate:linha:if} \Comment{$e\in F$}
\State $d$ $\gets$ \LCOMin($e_1$, $e_3$)\label{Algo:MSFupdate:linhamin}

\State $d_0$, $d_1$, $d_2$, $d_3$, $y_0$, $y_1$, $y_2$, $y_3$ $\gets$ $H(d)$
\If {$d_0$.$w$ < $w$}\label{Algo:MSFupdate:linha:compara}
\State \LCOCycle($d_1$); \LCOSplit($d_1$, $\hat d_3$, $\hat d_1$)
\State \LCOCycle($e_0$); \LCOSplit($e_0$, $\hat e_2$, $\hat e_0$ )\label{Algo:MSFupdate:linhasplit}

\State \LCOMerge($d_0$, $d_2$, $\hat d$); \LCOMerge($e_1$, $e_3$, $\hat e$)\label{Algo:MSFupdate:linhas:Merge}

\EndIf

\Else\Comment{$e^\star\in F^\star$}
\State $d$ $\gets$ \LCOMax($e_0$, $e_2$)\label{Algo:MSFupdate:dualinicio}

\State $d_0$, $d_1$, $d_2$, $d_3$, $y_0$, $y_1$, $y_2$, $y_3$ $\gets$ $H(d)$
\If {$d$.$w$ > $w$}
\State \LCOCycle($d_0$);\LCOSplit($d_0$, $\hat d_2$, $\hat d_0$)
\State \LCOCycle($e_1$);\LCOSplit($e_1$, $\hat e_3$, $\hat e_1$)

\State \LCOMerge($d_1$, $d_3$, $\hat d$); \LCOMerge($e_0$, $e_2$, $\hat e$)

\EndIf
\EndIf\label{Algo:MSFupdate:dualfim}
\end{algorithmic}
\end{algorithm}

Dado um grafo~$G$, um \defi{corte} é um conjunto de arestas cuja remoção aumenta o número de componentes conexas de~$G$.
Seja~$F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$.
Então existe um corte associado ao par $(F, uv)$ dado pela união de $uv$ com as arestas de~$G$ que reconectam as duas árvores de~$F$ geradas pela remoção de $uv$.
Por exemplo, o corte~$(F, a)$ é o conjunto de arestas~$\{a,~b,~c\}$.

\begin{theorem}
\label{teo:cutset}
Seja~$G$ um grafo plano, $F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$.
Então o conjunto
$$
(F, uv)^\star := \{e^\star:e\in (F, uv)\}
$$
forma um ciclo em $G^\star$.
\end{theorem}

Quando atualizamos o peso de uma aresta~$e$ de~$G$ para um novo peso~$w$, precisamos eventualmente atualizar a floresta~$F$ de peso mínimo que está sendo mantida de forma que ela continue sendo maximal e de peso mínimo.
Existem dois casos a serem tratados: Quando $e$ é uma aresta de $F$; e quando $e^\star$ é uma aresta de~$F^\star$.

No Algoritmo~\ref{Algo:MSFupdate}, essa distinção de casos é feita na linha~\ref{Algo:MSFupdate:linha:if}.
Se \LCOFindNode($e_0$) e \LCOFindNode($e_2$) retornarem o mesmo identificador~$\hat e$, então deduzimos que $e$ é uma aresta de~$F$.
Caso contrário, temos que $e^\star$ é uma aresta de $F^\star$.
Por exemplo, observando a Figura~\ref{fig:MSF-figura-3}, notamos que~\LCOFindNode($a_0$) e \LCOFindNode($a_2$) retornam o mesmo identificador~$\hat a$.
Enquanto que \LCOFindNode($c_0$) e \LCOFindNode($c_2$) retornam os identificadores distintos~$\hat c_0$ e~$\hat c_2$.

O primeiro caso é tratado entre as linhas~\ref{Algo:MSFupdate:linhamin} e~\ref{Algo:MSFupdate:linhas:Merge} do Algoritmo~\ref{Algo:MSFupdate}.
Nele~$e$ é uma aresta de~$F$ e é necessário verificar se não há alguma aresta no corte~$(F, e)$ com peso menor do que novo peso~$w$, pois se tal aresta existir, então~$F$ e~$F^\star$ não serão mais de peso mínimo em~$G$ e máximo em~$G^\star$, respectivamente.
Nesse caso, para corrigir isso, é necessário remover a aresta $e$ de~$F$ e adicionar em~$F$ uma aresta~$d$ de menor peso do corte~$(F, e)$.
Simetricamente, também é necessário remover $d^\star$ de~$F^\star$ e adicionar~$e^\star$ nessa floresta.

Pelo Teorema~\ref{teo:cutset}, o conjunto~$(F, e)^\star$ forma um ciclo em~$G^\star$.
Como~$e$ é a única aresta de~$F$ cuja aresta dual~$e^\star$ está em~$(F, e)^\star$, então as demais arestas desse corte formam um caminho~$P$ em~$F^\star$ ligando as faces incidentes a~$e^\star$.
Dessa forma, para obter~$d$, basta obter o mínimo no caminho~$P$.

As faces incidentes a~$e^\star$ são acessíveis nas ADPs pelos nós~$e_1$ e~$e_3$.
Assim, para obter~$d$, é executado \LCOMin($e_1$, $e_3$), que é feito na linha~\ref{Algo:MSFupdate:linhamin} do Algoritmo~\ref{Algo:MSFupdate}.
A Figura~\ref{fig:MSF-figura-5} ilustra o caminho~$P$ para o corte $(F,~a)$.
No exemplo, \LCOMin($a_1$, $a_3$) retorna o identificado $\hat c$.


Em seguida, na linha~\ref{Algo:MSFupdate:linha:compara} do Algoritmo~\ref{Algo:MSFupdate}, o novo peso~$w$ é comparado com o peso do vértice~$d$.
Caso $w$ seja menor do que o peso de~$d$, nada precisa ser feito.
Caso contrário, na linha~\ref{Algo:MSFupdate:linhasplit} do Algoritmo~\ref{Algo:MSFupdate}, as arestas~$e$ e~$d^\star$ são removidos de~$F$ e de~$F^\star$ utilizando a rotina~\LCOSplit{}, que converte os nós~$\hat e$ e~$\hat d$ nos nós $\hat e_0$,~$\hat e_2$, $\hat d_1$ e~$\hat d_3$, que se são as novas folhas associadas às arestas~$e$ e~$d$.
Para adicionar as arestas~$e^\star$ a~$F^\star$ e $d$ a~$F$ são usadas as folhas~$\hat d_0$, $\hat d_2$, $\hat e_1$ e~$\hat e_3$ junto à rotina \LCOMerge{} na linha~\ref{Algo:MSFupdate:linhas:Merge} do Algoritmo~\ref{Algo:MSFupdate}.

\begin{figure}[htb]
\begin{subfigure}{.3\textwidth}
\scalebox{.8}{
\input{fig/MSF-basico-5}
}
\caption{Caminho entre nós $a_1$ e~$a_3$ em~$\hat T^\star$.}
\label{fig:MSF-figura-5}
\end{subfigure}
\hspace{1cm}
\begin{subfigure}{.6\textwidth}
\scalebox{.8}{
\input{fig/MSF-basico-6}
}
\caption{ADPs com as arestas $a$ e $c^\star$ cortadas de $\hat T$ e~$\hat T^\star$, respectivamente.}
\label{fig:MSF-figura-6}
\end{subfigure}
\caption{Etapas da mudança de peso \MSFupdate($G$, $a$, $5$)}
\end{figure}

Concluindo o exemplo, o peso de $\hat c$ é $3$ que é menor do que o novo peso~$5$ de~$\hat a$.
A Figura~\ref{fig:MSF-figura-6} ilustra esse exemplo logo após a linha~\ref{Algo:MSFupdate:linhasplit} e antes da linha~\ref{Algo:MSFupdate:linhas:Merge} do Algoritmo~\ref{Algo:MSFupdate}.
Note que há duas árvores azuis e duas vermelhas.
A Figura~\ref{fig:MSF-figura-7} ilustra esse exemplo após a conclusão da chamada \MSFupdate($G$, $a$, $5$).

\begin{figure}[htb]
\scalebox{1}{
\centering
\input{fig/MSF-basico-7}
}
\caption{ADPs após a execução de~\MSFupdate($G$, $a$, $5$).}
\label{fig:MSF-figura-7}
\end{figure}

O segundo caso, quando~$e$ não for uma aresta de~$F$, então~$e^\star$ é uma aresta de~$F^\star$.
O tratamento desse caso é simétrico ao primeiro caso e é feito entre as linhas~\ref{Algo:MSFupdate:dualinicio} e~\ref{Algo:MSFupdate:dualfim} do Algoritmo~\ref{Algo:MSFupdate}.


\subsection{Remoção de aresta}

Ao remover uma aresta~$e$ de um grafo plano ponderado dinâmico~$G$, além de remover $e$ de $\hat F$ ou $e^\star$ de~$\hat F^\star$ é necessário também atualizar a estrutura de~$\hat F^\star$, pois a remoção de $e$ modifica a estrutura de faces do grafo plano.
Pelo Lema~\ref{lemma:diestel}, existem dois tipos de arestas em~$G$: ou a aresta não está em ciclos em~$G$ e as duas faces incidentes a ela são iguais, ou essas faces são distintas e a aresta está em pelo menos um ciclo de~$G$.

No primeiro caso, a aresta~$e$ é uma ponte e sua remoção aumenta o número de componentes conexas de~$G$.
Como consideramos que cada uma dessas componentes possui uma face exterior própria, a remoção de~$e$ implica na divisão da face exterior em duas, que serão as faces exteriores das duas componentes resultantes.
Como exemplo, ao remover a aresta~$e$ do grafo~$G$ ilustrado na Figura~\ref{fig:MSF-basico-reprodicao} a face exterior~$F_0$ é separada nas faces $F_4$ e~$F_5$ da Figura~\ref{fig:MSF-remove-ponte}.


Já no segundo caso, a remoção de uma aresta~$e$ implica na junção das duas faces incidentes a essa aresta.
No exemplo, a remoção da aresta~$b$ do grafo ilustrado na Figura~\ref{fig:MSF-basico-reprodicao} resulta na junção das faces~$F_1$ e~$F_2$ resultando na face~$F_6$ ilustrada na Figura~\ref{fig:MSF-remove-nao-ponte}.

\begin{figure}[htb]
\begin{subfigure}{0.3\textwidth}
\scalebox{0.7}{
\input{fig/MSF-basico-1.tex}
}
\caption{Grafo da Figura~\ref{fig:MSF-basico-1}.}
\label{fig:MSF-basico-reprodicao}
\end{subfigure}
\begin{subfigure}{0.3\textwidth}
\scalebox{0.7}{
\input{fig/MSF-remove-ponte.tex}
}
\caption{Após a remoção de~$g$.}
\label{fig:MSF-remove-ponte}
\end{subfigure}
\begin{subfigure}{0.3\textwidth}
\scalebox{0.7}{
\input{fig/MSF-remove-nao-ponte}
}
\caption{Após remoção de~$b$.}
\label{fig:MSF-remove-nao-ponte}
\end{subfigure}
\caption{Exemplos de remoção de arestas.}
\label{fig:antes-depois-remocao}
\end{figure}


A implementação de \MSFdelEdge{} pode ser vista no Algoritmo~\ref{Algo:MSFdelEdge}.
Junto com a explicação do pseudocódigo, detalharemos o processamento das chamadas \MSFdelEdge($G$, $e$) e \MSFdelEdge($G$, $b$) para exemplificar os dois casos de remoção de aresta.

A identificação de qual caso uma aresta $e$ se encontra é feita na linha~\ref{Algo:MSFdelEdge:linha2} do Algoritmos~\ref{Algo:MSFdelEdge}.
Nessa linha são comparados os valores de \LCOFindNode($v_1$) e \LCOFindNode($v_3$).
Esses valores são os identificadores das faces adjacêntes a~$e$.
Caso esses identificadores sejam iguais, então as faces incidentes a~$e$ são iguais e logo~$e$ não está em ciclos de~$G$.
Caso contrário, então~$e$ está em pelo menos um ciclo.
A aresta $e$ se encontra no primeiro caso, pois ambas as chamadas de~\LCOFindNode($e_{F_0}$) retornam o identificador $\hat F_0$.
Enquanto que~$b$ se encontra no segundo caso, já que~\LCOFindNode($b_u$) retorna $\hat u$, enquanto que~\LCOFindNode($b_v$) retorna~$\hat v$.

O primeiro caso é tratado entre as linhas~\ref{Algo:MSFdelEdge:linha3} e~\ref{Algo:MSFdelEdge:linha12} do Algoritmo~\ref{Algo:MSFdelEdge}.
Remover uma aresta~$e$ das ADPs consiste em desconectar a óctupla de~$e$ do restante da ADP. 
Para desconectar um nó~$v_i$ de sua ordem cíclica são chamadas as rotinas \LCOCycle($v_i$) e \LCOSplit($v_i$) em sucessão.
A rotina \LCOCycle($v_i$) garante que a ordem cíclica que contém~$v_i$ tenha forma $\alpha v_i$, enquanto que a rotina \LCOSplit($v_i$) separa essa ordem em duas: a primeira contendo todos os nós anteriores a~$v_i$ e a segunda com~$v_i$ e todos os nós sucessores, mas como a ordem tem forma $\alpha v_i$, então as duas ordens resultantes são~$\alpha$ e~$v_i$.
Ou seja, o nó~$v_i$ foi desconectado do restante da ordem cíclica.
Esse processo é feito para $v_0$, $v_1$ e~$v_2$ nas linhas~\ref{Algo:MSFdelEdge:linha3} e~\ref{Algo:MSFdelEdge:c1:v2}.
Relembramos que a óctupla de~$e$ e~$b$ estão ilustradas na Figura~\ref{fig:MSF-octo}.

Antes de desconectar $v_3$ de sua ordem cíclica, a face exterior~$F_e$ que contém~$v_1$ e~$v_3$ em sua ordem cíclica é dividida nas duas faces exteriores das duas componentes conexas~$G_1$ e~$G_2$ obtidas pela remoção de~$e$ de~$G$.
As duas pontas do laço~$e^\star$, representadas por~$v_1$ e~$v_3$ nas ADPs, dividem a ordem cíclica de~$F_e$ em duas partes.
A primeira contendo todos os nós entre~$v_1$ e~$v_3$ e a segunda possuindo todos os nós de~$v_3$ a~$v_1$ seguindo a ordem. 
Isto é, se a ordem de~$F_e$ tem forma $\alpha v_1\beta v_3\gamma$, então essas duas partes têm forma~$\gamma\alpha$ e~$\beta$.
Essas duas partes são as ordens cíclicas das futuras faces exteriores de~$G_1$ e~$G_2$, como ilustra a Figura~\ref{fig:MSF-ordem-ciclica-ponte}.

Após a desconexão de $v_1$ com as chamadas \LCOCycle($v_1$) e \LCOSplit($v_1$), feitas na linha~\ref{Algo:MSFdelEdge:c1:v1}, a ordem cíclica da face~$\hat F_e$ resultante dessas operações tem forma $\beta v_3\gamma\alpha$.
Então, para separar $\beta$ de~$\gamma\alpha$, é executado um $\LCOSplit$ em $v_3$ na linha~\ref{Algo:MSFdelEdge:c1:split}, obtendo dois vértices com ordens cíclicas~$\beta$ e~$v_3\gamma\alpha$.
Em seguinda, $v_3$ é desconectado da segunda ordem cíclica na linha~\ref{Algo:MSFdelEdge:linha12}.
Por fim, na linha~\ref{Algo:MSFdelEdge:linha:desaloca} a óctupla de~$e$ é desalocada da memória.

Na Figura~\ref{fig:MSF-ordem-ciclica-ponte-e}, podemos ver as ADPs logo antes da linha~\ref{Algo:MSFdelEdge:c1:split} do Algoritmo~\ref{Algo:MSFdelEdge}.
Após desconectar o nó~$g_{F_0}$ que está ligado a $g_1$, a ordem cíclica da face exterior~$\hat F_0$ é $\langle d_{F_0}, a_{F_0}, c_{F_0}, g_{F_0}, f_{F_0}\rangle$.
Logo, nesse caso, temos que $\gamma\alpha$ e $\beta$ são respectivamente $\langle f_{F_0} \rangle$ e~$\langle d_{F_0}, a_{F_0}, c_{F_0}\rangle$.
Essas são as duas ordens cíclicas das faces exteriores~$F_5$ e $F_4$ ilustradas na Figura~\ref{fig:MSF-remove-ponte}.

\begin{figure}[htb]
\begin{subfigure}{.4\textwidth}
\input{fig/MSF-ordem-ciclica-ponte}
\caption{Ordens cíclicas da face exterior~$F_e$.}
\label{fig:MSF-ordem-ciclica-ponte}
\end{subfigure}
\hfill
\begin{subfigure}{.4\textwidth}
\input{fig/MSF-remove-sem-e1}
\caption{ADPs logo antes da linha~\ref{Algo:MSFdelEdge:c1:split} do Algoritmo~\ref{Algo:MSFdelEdge}.}
\label{fig:MSF-ordem-ciclica-ponte-e}
\end{subfigure}
	\caption{Ordens cíclicas de faces exteriores. Figura~\ref{fig:MSF-ordem-ciclica-ponte} representa o caso genérico. Figura~\ref{fig:MSF-ordem-ciclica-ponte-e} ilustra as ADPS da Figura~\ref{fig:MSF-figura-4} ao remover a aresta~$e$.}
\end{figure}



\begin{algorithm}[hbt]
\caption{\MSFdelEdge($G$, $e$)}
\label{Algo:MSFdelEdge}
\begin{algorithmic}[1]
\State $e_0$, $e_1$, $e_2$, $e_3$, $v_0$, $v_1$, $v_2$, $v_3$ $\gets$ $H(e)$
\If {\LCOFindNode($v_1$) $=$ \LCOFindNode($v_3$) }\label{Algo:MSFdelEdge:linha2}\Comment{$e^\star$ é um laço de $G^\star$}

\State \LCOCycle($v_0$); \LCOSplit($v_0$)\label{Algo:MSFdelEdge:linha3}
\State \LCOCycle($v_1$); \LCOSplit($v_1$)\label{Algo:MSFdelEdge:c1:v1}
\State \LCOCycle($v_2$); \LCOSplit($v_2$)\label{Algo:MSFdelEdge:c1:v2}
\State \LCOSplit($v_3$) \label{Algo:MSFdelEdge:c1:split}
\State \LCOCycle($v_3$); \LCOSplit($v_3$)\label{Algo:MSFdelEdge:linha12}
\Else\Comment{$e$ está em um ciclo em $G$}
\State \MSFupdate($G$, $e$, $\infty$)\label{Algo:MSFdelEdge:linha:mudaPeso}
\State \LCOCycle($e_1$); \LCOSplit($e_1$) \label{Algo:MSFdelEdge:linha:split}
\State \LCOCycle($v_1$); \LCOCycle($v_3$); \LCOMerge($v_1$, $v_3$) \label{Algo:MSFdelEdge:linha:merge}
\State \LCOCycle($v_0$); \LCOSplit($v_0$) \label{Algo:MSFdelEdge:linha:1cs}
\State \LCOCycle($v_1$); \LCOSplit($v_1$)
\State \LCOCycle($v_2$); \LCOSplit($v_2$)
\State \LCOCycle($v_3$); \LCOSplit($v_3$)
	\label{Algo:MSFdelEdge:linha:ucs}
	\label{Algo:MSFdelEdge:linha:fim}
\EndIf
\State \LCODestroyOcto($H$, $e$)\label{Algo:MSFdelEdge:linha:desaloca}
\end{algorithmic}
\end{algorithm}

O segundo caso é tratado entre as linhas~\ref{Algo:MSFdelEdge:linha:mudaPeso} e~\ref{Algo:MSFdelEdge:linha:fim} do Algoritmo~\ref{Algo:MSFdelEdge}.
Nesse caso, a remoção de~$e$ não desconecta sua componente conexa.
Dessa forma, caso~$e$ seja uma aresta de~$F$, é necessário buscar uma aresta que a substituirá em~$F$, assim mantendo~$F$ como maximal.
Para fazer essa busca eficientemente, na linha~\ref{Algo:MSFdelEdge:linha:mudaPeso} do Algoritmo~\ref{Algo:MSFdelEdge}, o peso de~$e$ é mudado para~$\infty$, fazendo com que $e^\star$ se torne uma aresta de~$F^\star$. 
Em nosso exemplo, note que \MSFupdate($G$, $b$, $\infty$) não altera as estruturas das ADPs, já que $b^\star$ já é uma aresta de~$\hat T^\star$.

Em seguida, na linha~\ref{Algo:MSFdelEdge:linha:split} do Algoritmo~\ref{Algo:MSFdelEdge}, o vértice~$\hat e^\star$ é dividido nos dois vértices~$\hat e_1$ e~$\hat e_3$. 
Essa operação quebra a ADP~$\hat T^\star$ em duas, assim tornando possível juntar as faces~$F_e$ e~$F'_e$ incidentes a~$e$.
A junção dessas faces ocorre na linha~\ref{Algo:MSFdelEdge:linha:merge} do Algoritmo~\ref{Algo:MSFdelEdge} e é feita de forma que a descrição combinatória resultante se mantenha plana, isto é, se $\alpha v_1 \beta$ e $\gamma v_3 \delta$ são as ordens cíclicas de~$\hat F_e$ e~$\hat F'_e$, respectivamente, então $\alpha \delta\gamma\beta$ é a ordenação cíclica da face resultante.
Como ilustra a Figura~\ref{fig:MSF-ordem-ciclica-nao-ponte}

\begin{figure}[h!]
\begin{subfigure}{.4\textwidth}
\input{fig/MSF-ordem-ciclica-nao-ponte}
\caption{Ordens cíclicas da face exterior~$F_e$.}
\label{fig:MSF-ordem-ciclica-nao-ponte}
\end{subfigure}
\hfill
\begin{subfigure}{.4\textwidth}
\input{fig/MSF-ordem-ciclica-nao-ponte-depois}
\caption{ADPs logo antes da linha~\ref{Algo:MSFdelEdge:c1:split} do Algoritmo~\ref{Algo:MSFdelEdge}.}
\label{fig:MSF-ordem-ciclica-nao-ponte-depois}
\end{subfigure}
\caption{Ordens cíclicas de faces exteriores. Figura~\ref{fig:MSF-ordem-ciclica-ponte} representa o caso genérico. Figura~\ref{fig:MSF-ordem-ciclica-ponte-e} ilustra as ADPS da Figura~\ref{fig:MSF-figura-4} ao remover a aresta~$e$.}
\end{figure}


Como feito no caso anterior, é necessário desconectar a óctupla de~$e$ do restantes das ADPs, isso é feito entre as linhas~\ref{Algo:MSFdelEdge:linha:1cs} e~\ref{Algo:MSFdelEdge:linha:ucs} com uma sequência de chamadas de \LCOCycle($v_i$); \LCOSplit($v_i$).


A remoção de~$e$ implica na junção das duas faces distintas $F_0$ e $F_2$ incidentes a essa aresta.

\subsection{Adição de aresta}

Só é possível adicionar uma nova aresta entre dois vértices $u$ e $v$ se esses vértices estiverem em componentes distintas ou se existir uma face cuja fronteira contém ambos~$u$ e~$v$.
A adição de uma aresta fora dessas condições quebraria a planaridade do grafo. 
O processamento da rotina \MSFaddEdge{}, cuja implementação é descrita no Algoritmo~\ref{Algo:MSFaddEdge}, começa com a verificação dessas condições.
Para isso, primeiro é obtido os valores da tabela de símbolos~$f_i$, $u_i$, $g_i$ e $v_i$, para $0\leq i \leq 3$, associados às arestas~$f$ e $g$.
Em seguida, é utilizado a função \LCOFindNode{} para identificar qual nó de link cut tree, $u_0$ ou $u_2$ e $v_0$ ou $v_2$, está na ordem cíclica de~$u$ e~$v$, respectivamente.
Na linha \ref{Algo:MSFaddEdge:linhaSe}, é verificado se~$u$ e~$v$ estão na mesma componente e se há face cuja fronteira contém $u$ e $v$.
Note que como a nova aresta será sucessora de $f$ e $g$ em suas ordens cíclicas, então essa face em comum deve ser a face obtida por \LCOFindNode($u_{i-1}$) e \LCOFindNode($v_{i-1}$), onde a subtração no índice é feito em módulo~$4$.

Se a verificação falhar, o algoritmo retorna um erro. Caso contrário, para cada índice $i \in \{0, 1, 2, 3\}$, novos nós de link cut trees~$s_i$ e~$e_i$ são criados com \LCOMakeNode(), seus custos são atribuídos utilizando \LCOAddCost{} e $e_i$ é ligado a $s_i$ com a função \linkcutAddEdge{}.
Depois, são atribuídos valores infinitos e menos infinitos como pesos para os nós $s_i$ e a tabela de símbolos~$H$ é atualizado com esses valores.

O bloco de linhas~\ref{Algo:MSFaddEdge:começo} até~\ref{Algo:MSFaddEdge:fim} executa um conjunto de \LCOCycle{} e~\LCOMerge{} para juntar os nós~$s_i$ às ordens cíclicas dos vértices apropriados.  
Em seguida, o algoritmo acerta a estrutura da face.
Se os dois vértices estiverem conectados, então é necessário aplicar \LCOSplit{} para dividir a face \LCOFindNode($u_{i-1}$) em duas.
Caso contrário, é necessário aplicar um \LCOMerge para juntar as faces exteriores das duas componentes conexas.

\begin{algorithm}[htb]
\caption{\MSFaddEdge($G$, $e$, $u$, $f$, $v$, $g$, $w$)}
\label{Algo:MSFaddEdge}
\begin{algorithmic}[1]

\State $f_0$, $f_1$, $f_2$, $f_3$, $u_0$, $u_1$, $u_2$, $u_3$ $\gets$ $H(f)$
\State $g_0$, $g_1$, $g_2$, $g_3$, $v_0$, $v_1$, $v_2$, $v_3$ $\gets$ $H(g)$

\If {\LCOFindNode($u_0$) $=$ $u$} $i$ $\gets$ $0$
\Else {~$i$ $\gets$ $2$}
\EndIf
\If {\LCOFindNode($v_0$) $=$ $v$} $j$ $\gets$ $0$
\Else {~$j$ $\gets$ $2$}
\EndIf

\If{\LCOConnected($u$, $v$) e \LCOFindNode($v_{i-1}$) $\neq$ \LCOFindNode($u_{i-1}$)}\label{Algo:MSFaddEdge:linhaSe}
\State \Return Erro
\EndIf

\For {$i \in \{0,1,2,3\}$}
\State $s_i$ $\gets$ \LCOMakeNode(); $e_i$ $\gets$ \LCOMakeNode()
\State \linkcutAddEdge($e_i$, $s_i$)
\EndFor
\State \LCOAddCost($s_0$, $-\infty$); \LCOAddCost($s_2$, $-\infty$);
\State \LCOAddCost($s_1$, $\infty$); \LCOAddCost($s_3$, $\infty$);
\State $H(e)$ $\gets$ $e_0$, $e_1$, $e_2$, $e_3$, $s_0$, $s_1$, $s_2$, $s_3$

\State \LCOCycle($u_i$); \LCOMerge($u_i$, $s_0$)\label{Algo:MSFaddEdge:começo}
\State \LCOCycle($v_j$); \LCOMerge($v_j$, $s_2$)


\State \LCOCycle(\treapPredecessor($u_{i-1}$)); \LCOMerge($u_{i-1}$, $s_1$)
\State \LCOCycle(\treapPredecessor($v_{j-1}$)); \LCOMerge($v_{j-1}$, $s_3$)\label{Algo:MSFaddEdge:fim}

\If{\LCOConnected($u$, $v$)}

\State \LCOSplit($u_{j-1}$)
\Else
\State \LCOMerge($u_{i+1}$, $v_{j+1}$)
\EndIf
\State \MSFupdate($G$, $e$, $w$)
\end{algorithmic}
\end{algorithm}

\section{Estruturas auxiliares}

A implementação das árvores dinâmicas planas será detalhada na próxima seção.
Para construir essa estrutura de dados, são necessárias duas estruturas fundamentais: a primeira é a árvore binária de busca com chave implícita, discutida inicialmente em detalhes no Capítulo~\ref{sec:TreapDeChaveImplicita} e a segunda são as link cut trees, que serão abordadas brevemente na Seção~\ref{sec:linkcuttree}.

\subsection{Árvores binárias de busca com chave implícita}

Árvores binárias de busca com chave implícita são particularmente úteis para armazenar sequências de objetos, no Capítulo~\ref{sec:TreapDeChaveImplicita} elas foram utilizadas para armazenar um sequência de arestas que representa uma árvore.
No presente capítulo, elas serão usadas para armazenar a sequência de nós de link cut tree que representa a ordem cíclica de cada vértice.
Para implementar as rotinas presentes na biblioteca de ADPs, é necessário complementar a biblioteca de ABBs de chave implícita com as seguintes rotinas:
\begin{itemize}
\item \treapFirst($\node$): Retorna o nó de menor chave da ABB que contém $\node$.
\item \treapLast($\node$): Retorna o nó de maior chave da ABB que contém $\node$.
\item \treapSplitRight($\node$): Corta a ABB que contém um nó~$\node$ em duas ABBs. A primeira ABB contém todos os nós com chave menor ou igual a chave de~$\node$ e a segunda contém todos os nós com chave estritamente maior do que a chave de~$\node$. Essa rotina retorna as raízes dessas duas ABBs.
\item \treapPredecessor($\node$): Retorna o predecessor de $\node$.\TODO{Adicionar implementação dessa rotina}
\end{itemize}

A implementação dessas rotinas estão descritas nos Algoritmos~\ref{Algo:TREAPfirst},~\ref{Algo:TREAPlast} e~\ref{Algo:TREAPsplitRight}.
Seu consumo de tempo será $\O{\lg t}$ esperado, onde $t$ é o número de nós da árvore.
Como descrito no final da Seção~\ref{sec:MSFcomADP}, essas ABBs são usadas para armazenar a ordem cíclica de cada vértice, como o tamanho dessa ordem é linearmente proporcional ao número~$m$ de arestas no grafo dinâmico, concluímos que essas rotinas consumem $\O{\lg m}$ esperado.  

A rotina \treapFirst{}, descrita no Algoritmo~\ref{Algo:TREAPfirst}, começa seu processamento inicializando uma variável temporária, $p$, com o nó passado como argumento.
Em seguida, é usado a rotina $\treapGetRoot$, descrita no Algoritmo~\ref{Algo:treapGetRoot}, para obter a raiz da ABB que contém $\node$.
Depois de obter a raiz, o algoritmo desce pela árvore, movendo-se sempre para o filho esquerdo, até alcançar o nó mais à esquerda, que representa o nó com menor chave.
Finalmente, o nó encontrado é retornado.

\begin{algorithm}
\caption{\treapFirst($\node$)}
\label{Algo:TREAPfirst}
\begin{algorithmic}[1]
\State $p$ $\gets$ $\treapGetRoot(\node)$

\While { $p$.$esq$ $\neq \Nil$}
  \State $p$ $\gets$ $p$.$esq$
\EndWhile

\State\Return $p$
\end{algorithmic}
\end{algorithm}

A rotina \treapLast{}, descrita no Algoritmo~\ref{Algo:TREAPlast}, é análoga à rotina \treapFirst{}.
Ele também começa inicializando uma variável temporária, $u$, com o nó passado como argumento e em seguida, usando $\treapGetRoot$, obtém a raiz da ABB que contém $\node$.
Mas diferentemente de \treapFirst{}, após obter a raiz, $\treapLast$ desce pela árvore, movendo-se sempre para o filho direito, até alcançar o nó mais à direita, que representa o nó com maior chave, que é retornado.

\begin{algorithm}
\caption{\treapLast($\node$)}
\label{Algo:TREAPlast}
\begin{algorithmic}[1]
\State $u$ $\gets$ $\treapGetRoot(\node)$

\While { $u$.\varname{dir} $\neq \Nil$}
  \State $u$ $\gets$ $u$.\varname{dir}
\EndWhile

\State\Return $u$
\end{algorithmic}
\end{algorithm}

A implementação de \treapSplitRight{}, que pode ser vista no Algoritmo~\ref{Algo:TREAPsplitRight}, é quase idêntica a de \treapSplit{}, que foi descrito no Algoritmo~\ref{Algo:TREAPsplit}.
A única diferença entre essas rotinas é na linha~\ref{Algo:TREAPsplitRight:linha:atribuicao}, em que atribuímos~$\node$ a~$L$ em vez de~$\node$.\varname{esq}, como feito em \treapSplit{}.

\begin{algorithm}
\caption{\treapSplitRight($\node$)}
\label{Algo:TREAPsplitRight}
\begin{algorithmic}[1]
\State $R$ $\gets $ $\node$.\varname{dir}
\State $L$ $\gets $ $\node$ \label{Algo:TREAPsplitRight:linha:atribuicao}
\State \varname{tmp} $\gets$ $\node$
\While { \varname{tmp}.\varname{pai} $\neq \Nil$}
  \If { \varname{tmp}.\varname{pai}.\varname{esq} = \varname{tmp}}
    \State \varname{tmp}.\varname{pai}.\varname{esq} $\gets$ $R$
    \State \varname{tmp}.\varname{pai}.$tam$ $\gets$ \varname{tmp}.\varname{pai}.$tam$ $\mathit{-}$ \treapGetSize($L$)
    \If { $R \neq \Nil$}
    \State $R$.\varname{pai} $\gets$ \varname{tmp}.\varname{pai}
    \EndIf
    \State $R$ $\gets$ \varname{tmp}.\varname{pai}
  \Else
    \State \varname{tmp}.\varname{pai}.\varname{dir} $\gets$ $L$ 
    \State \varname{tmp}.\varname{pai}.$tam$ $\gets$ \varname{tmp}.\varname{pai}.$tam$ $\mathit{-}$ \treapGetSize($R$)
    \If { $L$ $\neq$ \Nil}
    \State $L$.\varname{pai} $\gets$ \varname{tmp}.\varname{pai}
    \EndIf
    \State $L$ $\gets$ \varname{tmp}.\varname{pai}
  \EndIf
  \State \varname{tmp} $\gets$ \varname{tmp}.\varname{pai}
\EndWhile
\If { $L$ $\neq \Nil$} $L$.\varname{pai} $\gets\Nil$\EndIf
\If { $R$ $\neq \Nil$} $R$.\varname{pai} $\gets\Nil$\EndIf
\State $\node$.\varname{dir} $\gets $ $\node$.\varname{esq} $\gets$ $\node$.\varname{pai} $\gets$ $\Nil$
\State\Return $L$, $R$
\end{algorithmic}
\end{algorithm}

\subsection{Link cut trees}
\label{sec:linkcuttree}
Link-cut trees são uma estrutura de dados usada para representar e manipular florestas dinâmicas enraizadas.
Elas foram originalmente introduzidas por Sleator e Tarjan~\cite{SleatroTarjanLinkCutTree1983,} em~1983 e dão suporte às seguintes operações:
\begin{itemize}
\item \linkcutCreate(): Cria e retorna um novo nó de link-cut tree.
\item \linkcutAddEdge($v$, $w$): Adiciona uma aresta de~$v$ a~$w$, tornando~$v$ um filho de~$w$. Essa operação assume que~$v$ é a raiz de sua árvore e que $w$ não é um nó da árvore de~$v$.
\item \linkcutDelEdge($v$): Remove a aresta de~$v$ para seu pai.
	Essa operação assume que~$v$ não é a raiz de sua árvore.
\item \linkcutEvert($v$): Torna~$v$ a raiz de sua árvore revertendo o caminho de~$v$ para a raiz original.
\item \linkcutMax($v$): Retorna o nó de peso máximo no caminho entre~$v$ e a raiz de sua árvore.
\item \linkcutMin($v$): Retorna o nó de peso mínimo no caminho entre~$v$ e a raiz de sua árvore.
\end{itemize}


Para uma introdução sobre link-cut trees, recomendamos o trabalho de~\cite{linkcuttree}.

\section{Implementação de árvores dinâmicas planas}
\label{sec:implementacao-ADP}

Nessa seção, vamos mostrar como usar link cut trees para implementar árvores dinâmicas planas. As implementações de \LCOMakeNode{}, \LCOAddCost{}, \LCOMax{}, \LCOMin, \LCOFindNode{} são imediatas.

Na rotina \LCOMakeNode{} são criados um novo nó de link cut tree com a rotina \linkcutCreate{} e um novo nó~$T$ de ABB de chave implícita.
Então o campo~$\node$ de~$T$ é atribuído o novo nó de link cut tree, que é retornado em seguida. Veja o Algoritmo~\ref{Algo:LCOMakeNode}.

\begin{algorithm}[htb]
\caption{\LCOMakeNode()}
\label{Algo:LCOMakeNode}
\begin{algorithmic}[1]
\State $\node$ $\gets$ \linkcutCreate()
\State $T$ $\gets$ \treapCreate()
\State $T$.$\node$ $\gets$ $\node$
\State \Return $\node$
\end{algorithmic}
\end{algorithm}

A rotina \LCOAddCost{}, descrita no Algoritmo~\ref{Algo:LCOAddCost}, primeiro realiza um \linkcutEvert{} no último nó da ordem ciclica que contém~$p$.
Dessa forma, o caminho entre os nós \treapFirst($p$) e \treapLast($p$) coincide com a ordem ciclica que contém~$p$.
Em seguida, a rotina \linkcutWeight{} atribui o peso~$w$ para todos os nós entre \treapFirst($p$) e a raiz da sua árvore, isto é, \treapLast($p$).
Logo todos os nós da ordem cíclica que contém $p$ têm seus pesos atualizados para o novo valor~$w$.

\begin{algorithm}[htb]
\caption{\LCOAddCost($p$, $w$)}
\label{Algo:LCOAddCost}
\begin{algorithmic}[1]
\State \linkcutEvert(\treapLast($p$))
\State \linkcutWeight(\treapFirst($p$), $w$)
\end{algorithmic}
\end{algorithm}

As implementações das rotinas \LCOMax{} e~\LCOMin{} são análogas.
Em ambas, é chamado \linkcutEvert($p$).
Em seguida, é atribuído à variável~$m$ o valor de \linkcutMax($q$) (resp. \linkcutMin($q$)), que corresponde ao nó com maior (resp. menor) peso entre $q$ e a raiz da link cut tree, isto é, $p$.
Então é retornado o valor \LCOFindNode($m$).
Veja os Algoritmos~\ref{Algo:LCOMax} e~\ref{Algo:LCOMin}.

\begin{algorithm}[htb]
\caption{\LCOMax($p$, $q$)}
\label{Algo:LCOMax}
\begin{algorithmic}[1]
\State \linkcutEvert($p$)
\State $m$ $\gets$ \linkcutMax($q$)
\State \Return \LCOFindNode($m$)
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[htb]
\caption{\LCOMin($p$, $q$)}
\label{Algo:LCOMin}
\begin{algorithmic}[1]
\State \linkcutEvert($p$)
\State $m$ $\gets$ \linkcutMin($q$)
\State \Return \LCOFindNode($m$)
\end{algorithmic}
\end{algorithm}

A implementação de \LCOFindNode{} é simples e usa a estrutura de árvores binárias de busca com chave implícita.
Dado o nó~$s$, sabemos que ele está em alguma ABB e que a raiz dessa árvore aponta para o nó que contém~$s$ em sua ordem cíclica,
logo usamos \treapGetRoot{} da biblioteca de ABBs para obter a raiz~$r$ da árvore e em seguida é retornado~$r$.$\node$.

\begin{algorithm}[htb]
\caption{\LCOFindNode($s$)}
\label{Algo:LCOFindNode}
\begin{algorithmic}[1]
\State $r$ $\gets$ \treapGetRoot($s$)
\State \Return $r$.$\node$
\end{algorithmic}
\end{algorithm}


A implementação da rotina \LCOMerge{} pode ser vista no Algoritmo~\ref{Algo:LCOMerge}.
O processo de \LCOMerge{} começa chamando a função \linkcutEvert{} invertendo a árvore de modo que o nó~\treapLast($p$) se torne a nova raiz.
Isso é necessário, pois a operação \linkcutAddEdge{} de adição de aresta subsequente assume que \treapLast($p$) é a raiz de sua árvore.
A função \linkcutAddEdge{} é usada para adicionar uma aresta entre~\treapLast($p$) e~\treapFirst($q$), conectando o último nó da ordem cíclica do vértice que contém~$p$ ao primeiro nó da ordem cíclica do vértice que contém~$q$.
Para garantir que a ordem cíclica das arestas seja mantida corretamente, a função \treapJoin{} é chamada para unir as raízes das ABBs associadas aos vértices.

\begin{algorithm}[htb]
\caption{\LCOMerge($p$, $q$)}
\label{Algo:LCOMerge}
\begin{algorithmic}[1]
\State $l$ $\gets$ \treapLast($p$)
\State \linkcutEvert($l$)
\State \linkcutAddEdge($l$, \treapFirst($q$))
\State $T$ $\gets$ \treapJoin(\treapGetRoot($p$), \treapGetRoot($q$))
\State $T$.$\node$ $\gets$ $w$ \TODO{???}
\end{algorithmic}
\end{algorithm}

A implementação da rotina \LCOSplit($p$) pode ser vista no Algoritmo~\ref{Algo:LCOSplit}.
Nessa implementação, primeiro, a função \linkcutEvert{} é torna \treapLast($p$) a raiz da sua link cut tree, assim o caminho entre \treapFirst($p$) e a raiz corresponde à ordem cíclica de $v$.
Dessa forma \linkcutParent($p$) retorna o sucessor do nó $p$ na ordem cíclica, que é armazenado na variável~$y$ e ao aplicar \linkcutDelEdge($p$) a ordem cíclica de~$v$ é dividida em duas sequências, a primeira de \treapFirst($p$) até $p$ e a segunda de~$y$ até~\treapLast($p$).
Essas sequências correspondem às ordens cíclicas dos vértices resultantes desejados.
Finalmente, a árvore binária de busca que contém o nó~$p$ é então dividida em duas partes: uma que mantém a ordem das arestas até $p$, e outra que contém o restante.

\begin{algorithm}[htb]
\caption{\LCOSplit($p$)}
\label{Algo:LCOSplit}
\begin{algorithmic}[1]
\State \linkcutEvert(\treapLast($p$))
\State $y$ $\gets$ \linkcutParent($p$)
\State \linkcutDelEdge($p$)
\State $T$, $T'$ $\gets$ \treapSplitRight($p$)
\State $T$.$\node$ $\gets$ $w$\TODO{???}
\State $T'$.$\node$ $\gets$ $v$\TODO{???}
\end{algorithmic}
\end{algorithm}


A implementação da rotina \LCOCycle($\hat u$, $\hat e$) pode ser visto no Algoritmo~\ref{Algo:LCOCycle}.
O processo começa comparando~$p$ com o último nó da ordem cíclica que o contém.
Caso esses nós sejam iguais, então a função termina imediatamente.
Caso contrário, a função $\linkcutEvert$ é aplicada a \treapLast($p$).
Essa operação faz com que o pai de~$p$ seja o sucessor dele na ordem cíclica.
Então é usada a rotina $\linkcutParent$ para obter esse sucessor~$x$ e remove-se a aresta que liga~$p$ a~$x$.
Em seguida, a função $\linkcutAddEdge$ adiciona uma nova aresta que conecta o último nó da ordem cíclica que contém~$p$ ao primeiro nó dessa ordem, efetivamente ajustando a ordem cíclica.
Finalmente, a árvore binária de busca associada é dividida em partes, reorganizadas, e depois unidas para representar a nova ordem cíclica, garantindo que~$p$ seja, de fato, o último nó na ordem cíclica.


\begin{algorithm}[htb]
\caption{\LCOCycle($p$)}
\label{Algo:LCOCycle}
\begin{algorithmic}[1]
\State $l$ $\gets$ \treapLast($p$)
\If{$l$ $=$ $p$}
\State\Return
\EndIf
\State \linkcutEvert($l$)
\State $x$ $\gets$ \linkcutParent($p$)
\State \linkcutDelEdge($p$)
\State \linkcutAddEdge($l$, \treapFirst($p$))
\State $T$, $T'$ $\gets$ \treapSplitRight($p$)
\State $T$ $\gets$ \treapJoin($T'$, $T$)
\State $T$.$\node$ $\gets$ $p$
\end{algorithmic}
\end{algorithm}
