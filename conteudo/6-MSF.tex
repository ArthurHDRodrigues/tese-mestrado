\chapter{Floresta maximal de peso mínimo em grafos planos}
\label{sec:MSF}


Retomemos o problema da floresta maximal de peso mínimo em grafos dinâmicos inicialmente apresentado na Seção~\ref{sec:Motivação} e que é o segundo problema que iremos apresentar.
Ele consiste na busca por uma implementação tão eficiente quanto possível para a seguinte biblioteca:

\begin{itemize}
\item \MSFCreate($G_0$): recebe um grafo plano ponderado~$G_0$ dado por listas de adjacências e devolve um grafo dinâmico plano ponderado isomorfo a~$G_0$; Para cada aresta~$uv$ em~$G_0$ também é informado a aresta dual~$uv^\star$, dessa forma fixando uma imersão no plano.
\item \MSFupdate($G$, $u$, $v$, $w$): atribui o peso~$w$ à aresta~$uv$ do grafo dinâmico~$G$.
\item \MSFweight($G$): devolve o peso de uma MSF de $G$.
\end{itemize}


\section{Subdivisão planar e suas representações}

Definir:
\begin{itemize}
\item grafo planar
\item imersão no plano
\item grafo plano
\item grafo dual
\item corte induzido por uma árvore e uma aresta da árvore.
\end{itemize}

\begin{theorem}
\label{teo:MSFdual}
Dado uma floresta maximal~$F$ de um grafo planar~$G$, então o conjunto
$$
F^\star = \{e^\star|e\notin F\}
$$
é uma floresta maximal de~$G^\star$.
Além disso, se~$G$ for ponderado e adotarmos $w(e) = w(e^\star)$, então~$F$ será de peso mínimo se e somente se~$T^\star$ for de peso máximo e vice versa.
\end{theorem}


Dado um grafo~$G$, um \defi{corte} é um conjunto de arestas cuja remoção aumenta o conjunto de componentes conexas de~$G$.
Dado $F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$, então existe um corte associado ao par $(F, uv)$ dado pela união de $uv$ com as arestas que reconectam as duas árvores geradas pela remoção de $uv$.


\begin{theorem}
\label{teo:cutset}
Seja~$G$ um grafo planar, $F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$, então o conjunto
$$
(F, uv)^\star := \{e^\star|e\in (F, uv)\}
$$
forma um ciclo em $G^\star$.
\end{theorem}

\section{Link/Cut Tree}
\label{sec:linkcuttree}

Para uma introdução sobre link-cut trees, recomendamos o trabalho de~\cite{linkcuttree}.

Biblioteca de link/cut tree:
\begin{itemize}
\item \linkcutCreate($n$): recebe um vértice e devolve um nó de link/cut tree que representa esse vértice.
\item \linkcutAddEdge($F$, $u$, $v$, $w$): Adiciona a aresta~$uv$ com peso~$w$ à floresta~$F$.
\item \linkcutDelEdge($F$, $u$, $v$): Remove a aresta~$uv$ de~$F$.
\item \linkcutQuery($F$, $u$, $v$): Realiza uma consulta de conexidade entre os vértices~$u$ e~$v$.
\item \linkcutMax($F$, $u$, $v$): Retorna o nó com peso máximo no caminho entre~$u$ e~$v$ na floresta~$F$.
\item \linkcutMin($F$, $u$, $v$): Retorna o nó com peso mínimo no caminho entre~$u$ e~$v$ na floresta~$F$.
\end{itemize}

\section{Ideia do algoritmo}
Manteremos $F$ e sua floresta dual~$F^\star$ como definida no Teorema~\ref{teo:MSFdual} usando link-cut trees.

Para implementar \MSFCreate($G_0$), primeiro ordenamos as arestas de~$G_0$ em ordem crescente de peso e em seguida as inserimos sequencialmente em~$G$.
Antes de inserir uma aresta~$uv$, faremos um teste de conexidade entre~$u$ e~$v$, se~$u$ e~$v$ não estiverem conectados, então inserimos~$uv$ em~$F$, caso contrário inserimos $uv^\star$ em~$F^\star$.

\begin{algorithm}[htb]
\caption{\MSFCreate($n$, $G_0$)}
\label{Algo:MSFCreate}
\begin{algorithmic}[1]
\State \varname{lista} $\gets$ \order($G_0$)
\For{$uv$ em \varname{lista}}:
\If \linkcutQuery($F$, $u$, $v$)
\State \linkcutAddEdge($G$.$F^\star$, $e$, $f$, $w$)
\Else
\State \linkcutAddEdge($G$.$F$, $u$, $v$, $w$)
\EndIf
\EndFor
\State \Return $G$
\end{algorithmic}
\end{algorithm}

Como inserimos as arestas em ordem crescente de peso, a floresta~$F$ é de pesos mínimos e logo, pelo Teorema~\ref{teo:MSFdual}, $F^\star$ é de pesos máximos.

\begin{algorithm}[htb]
\caption{\MSFweight($G$)}
\label{Algo:MSFweight}
\begin{algorithmic}[1]
\State \Return $G$.$F$.$w$
\end{algorithmic}
\end{algorithm}

Quando atualizamos o peso de uma aresta~$uv$ com a rotina \MSFupdate{}, cuja implementação pode ser vista no Algoritmo~\ref{Algo:MSFupdate}, precisamos garantir que a floresta~$F$ resultante continuará sendo  de peso mínimo.
Notemos que ou $uv\in F$ ou $uv^\star\in F^\star$, iremos tratar esses casos separadamente.

Se~$uv$ for uma aresta de~$F$ e se existir alguma aresta no corte~$(F, uv)$ com peso menor do que~$w$, então $F$ não será mais de peso mínimo.
Para corrigir isso, precisamos tomar~$xy$ como a aresta de menor peso no corte~$(F, uv)$,
então remover~$uv$ de~$F$ e adicionar~$xy$ a~$F$.
Dessa forma, garantindo que~$F$ seja de peso mínimo.

Para obter a aresta~$xy$, vamos investigar o corte~$(F, uv)$.
Pelo Teorema~\ref{teo:cutset}, o conjunto~$(F, uv)^\star$ forma um ciclo em~$G^\star$.
Como~$uv^\star\in(F, uv)$ e~$uv$ é a única aresta de~$F$ cujo dual está em~$(F, uv)$, então as demais arestas desse corte formam um caminho em~$F^\star$ ligando os vértices incidentes a~$uv^\star$.
Utilizando a rotina \linkcutMin{}  da biblioteca de link/cut trees podemos obter o nó de menor peso nesse percurso.

Note também que, se modificarmos~$F$, então precisaremos atualizar~$F^\star$, removendo $xy^\star$ de~$F^\star$ e adicionando $uv^\star$ com o novo peso~$w$.

Se~$uv$ não for uma aresta de~$F$, então teremos que~$uv^\star$ é uma aresta de~$F^\star$.
O tratamento desse caso é analogo ao caso anterior e é feito entre as linhas~\ref{Algo:MSFupdate:dualinicio} e~\ref{Algo:MSFupdate:dualfim} do Algoritmo~\ref{Algo:MSFupdate}.


\begin{algorithm}[htb]
\caption{\MSFupdate($G$, $u$, $v$, $w$)}
\label{Algo:MSFupdate}
\begin{algorithmic}[1]
\State $e$,$f$ $\gets$ $uv^\star$
\If {$uv$ $\in$ $G$.$F$}

\State \varname{min} $\gets$ \linkcutMin($F^\star$, $e$, $f$)
\If {$\varname{min}$.$w$ > $w$}
\State \linkcutDelEdge($F$, $u$, $v$)
\State \linkcutAddEdge($F$, $u$, $v$, $w$)
\Else
\State $x$,$y$ $\gets$ \varname{min}
\State \linkcutDelEdge($F^\star$, $x$, $y$)
\State \linkcutAddEdge($F^\star$, $e$, $f$, $w$)
\State $x$,$y$ $\gets$ $\varname{min}^\star$
\State \linkcutDelEdge($F$, $u$, $v$)
\State \linkcutAddEdge($F$, $x$, $y$, \varname{min}.$w$)
\EndIf

\Else

\State \varname{max} $\gets$ \linkcutMax($F$, $u$, $v$)\label{Algo:MSFupdate:dualinicio}
\If {\varname{max}.$w$  < $w$}
\State \linkcutDelEdge($F^\star$, $e$, $f$)
\State \linkcutAddEdge($F^\star$, $e$, $f$, $w$)
\Else
\State $x$,$y$ $\gets$ \varname{max}
\State \linkcutDelEdge($F$, $x$, $y$)
\State \linkcutAddEdge($F$, $u$, $v$, $w$)
\State $x$,$y$ $\gets$ $\varname{max}^\star$
\State \linkcutDelEdge($F^\star$, $e$, $f$)
\State \linkcutAddEdge($F^\star$, $x$, $y$, \varname{max}.$w$)\label{Algo:MSFupdate:dualfim}
\EndIf

\EndIf
\end{algorithmic}
\end{algorithm}
