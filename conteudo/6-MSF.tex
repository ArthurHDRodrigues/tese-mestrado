\chapter{Floresta maximal de peso mínimo em grafos planos}
\label{sec:MSF}

O problema da floresta maximal de peso mínimo em grafos dinâmicos foi inicialmente apresentado na Seção~\ref{sec:Motivação} e é o segundo problema que iremos discutir.
Nesse capítulo, vamos apresentar o algoritmo de David Eppstein, Giuseppe Italiano, Roberto Tamassia, Robert Tarjan, Jeffery Westbrook e Moti Yung~\cite{EPPSTEIN-planar} que resolve esse problema para grafos que podem ter laços e arestas paralelas.

Começaremos o estudo desse problema com uma revisão de conceitos de planaridade e dualidade apresentados nas Seções~\ref{sec:planaridade} e~\ref{sec:dualidade}, respectivamente.
Esses conceitos serão usados para definir formalmente o problema, que é feito na Seção~\ref{sec:definition-MSF}, e para fundamentar a estrutura de dados que resolve esse problema, que será apresentada na Seção~\ref{sec:definition-MSF}.

%O algoritmo se aplica a grafos planares arbitrários porém, por simplicidade, em nossa exposição, nos restringiremos a grafos planares conexos.

\section{Planaridade}
\label{sec:planaridade}

Intuitivamente, um grafo é dito \defi[grafo!planar]{planar}~\cite{planarTheoryAlgorith} se é possível desenhá-lo no plano de forma que suas arestas não se cruzem e um grafo \defi[grafo!plano]{plano} é um grafo planar já desenhado no plano.

Formalmente, uma \defi{imersão no plano} de um grafo~$G=(V,E)$ é um par de funções \nolbreaks{$\phi_V:V\mapsto \R^2$} e $\phi_E: E\times [0,1]\mapsto \R^2$ tais que:
\begin{enumerate}
\item $\phi_V$ é injetora; 
\item $\phi_E(uv,0) = \phi_V(u)$ e $\phi_E(uv,1) = \phi_V(v)$, para toda aresta $uv\in E$;
\item $\phi_E(uv)$ é uma curva sem auto-intersecção.
\end{enumerate}
Usaremos somente $\phi$ para nos referirmos ao par $(\phi_V,\phi_E)$.

Um grafo~$G=(V,E)$ é dito \defi{planar}~\cite{noma2003} se existir imersão de~$G$ no plano tal que
\begin{enumerate}
\item A imagem das arestas não contém imagens de vértices no seu interior, ou seja, $\phi_E(uv,x) \neq \phi_V(w)$, para toda aresta $uv\in E$, vértice $w\in V$ e número real~$x$ tal que $0<x<1$;
\item As curvas associadas a quaisquer duas arestas distintas não se cruzam no seu interior, ou seja, $\phi_E(uv,x)\neq \phi_E(wz,y)$ para toda aresta $uv,wz\in E$ e $0<x,y<1$ números reais.
\end{enumerate}
Um grafo planar junto com uma imersão fixada é chamado de grafo \defi{plano}.

Dado um grafo plano~$G$ com imersão~$\phi$, se removermos a imagem de $\phi$ do plano obteremos regiões conexas chamadas de \defi{faces}~\cite{planarTheoryAlgorith}.
A fronteira de uma face~$f$ é a usa fronteira topológica e corresponde a um subgrafo de~$G$\TODO{Citar Diestel}.
Cada aresta está na fronteira de duas faces (não necessariamente distintas\TODO{Lema 4.2.1, Diestel}.
A Figura~\ref{fig:MSF-basico-0} mostra as faces de um grafo plano.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-0.tex}
}
\caption{Um grafo ponderado plano e suas faces.}
\label{fig:MSF-basico-0}
\end{figure}

\begin{theorem}[Fórmula de Euler]
\label{teo:MSFEuler}
Seja $G=(V,E)$ um grafo planar conexo com~$n$ vértices e~$m$ arestas. Toda imersão de~$G$ no plano possui o mesmo número $f$ de faces e
$$
n-m+f = 2.
$$
\end{theorem}

Para cada vértice $v$ de um grafo plano, é possível construir uma ordenação cíclica~$D(v)$ das aresta incidentes a~$v$~\cite{noma2003}.
Para obter essa ordenação, percorremos as arestas incidentes a~$v$ em sentido horário até retornar à aresta inicial do percurso.
Uma aresta $vu$ é \defi{sucessora} de uma aresta $vw$ se a primeira é sucessora da segunda nesse percurso.
Uma lista de todas essas ordens cíclicas é chamada de~\defi{descrição combinatória plana} da imersão.
A Tabela \TODO{bla} mostra as ordenações de cada vértice do grafo da Figura \TODO{bla}.

A \defi{descrição combinatória} de um grafo plano é essencialmente uma lista de adjacências em que a ordem das células é relevante.
Como estamos admitindo arestas paralelas, o número de ocorrêcias de um vértice~$u$ na lista de um vértice~$v$ será exatamente o número de arestas paralelas entre~$u$ e~$v$.
Um laço num vértice~$u$ corresponderá a duas ocorrências de~$u$ na sua lista de adjacências.

Para o algoritmo que vamos descrever nesse capítulo, cada aresta possui um identificador.
Observe que cada aresta corresponde a duas células nas listas de adjacência do grafo:
Se os extremos de uma aresta são~$u$ e~$v$, há uma célula com~$u$ na lista de~$v$ e uma célula com~$v$ na lista de~$u$, ambos representando essa aresta.

Pensamos nessas células como representações das duas possíveis orientações da aresta: de~$u$ para~$v$ (algumas vezes denotada por~$uv$) e de~$v$ para~$u$ (algumas vezes denotada por $vu$).
Essas duas células armazenarão o identificador da aresta e terão um apontador $\varname{sym}$, referenciando a outra e vice-versa.
Ademais, cada uma dessas células possuirá também um campo $\varname{orig}$, que identificará o vértice a cuja lista pertence, ou seja, o vértice que é a origem da aresta orientada representada pela célula.

É possível obter uma descrição combinatória plana em tempo linear~\TODO{Citar fonte}.

\section{Dualidade}
\label{sec:dualidade}


Dado um grafo plano, o grafo \defi{dual} de~$G$~\cite{planarTheoryAlgorith} é o grafo $G^\star = (F,E^\star)$ cujo conjunto de vértices é o conjunto~$F$ de faces de~$G$ e o conjunto de arestas $E^\star$ é construido a partir das arestas de~$G$.
Para cada aresta~$e\in E$, existe exatamente uma aresta~$e^\star$ no conjunto $E^\star$.
A aresta~$e^\star$ é chamada de \defi{aresta dual} de~$e$ e os vértices incidentes a essa aresta são as duas faces (não necessariamente distintas) cujas fronteiras contém~$e$.
Nesse contexto, chamamos~$G$ de grafo \defi{primal}.
Para ilustrar a relação entre cada aresta e seu dual, geralmente desenhamos cada aresta do grafo dual cruzando a correspondente aresta do grafo primal, como mostra a Figura~\ref{fig:MSF-basico-1}.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-1.tex}
}
\caption{Um grafo ponderado plano e seu dual.}
\label{fig:MSF-basico-1}
\end{figure}


Se~$G$ tem $n$ vértices e~$m$ arestas, o Teorema~\ref{teo:MSFEuler} mostra que o número de vértices do grafo dual é $\OTheta{n+m}$.

\begin{theorem}[\cite{EPPSTEIN-planar}]
\label{teo:MSFdual}
Seja~$T$ uma árvore geradora de um grafo plano conexo~$G$. O conjunto
$$
T^\star = \{e^\star:e\notin T\}
$$
é uma árvore geradora de~$G^\star$.
Além disso, se~$G$ for ponderado e adotarmos $w(e^\star) = w(e)$, então~$T$ será de peso mínimo se e somente se~$T^\star$ for de peso máximo e vice versa.
\end{theorem}

A Figura~\ref{fig:MSF-figura-2} mostra~$T$ e~$T^\star$ do grafo da Figura~\ref{fig:MSF-basico-1}.


\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-2}
}
\caption{Árvore geradora~$T$ de peso mínimo do grafo da Figura~\ref{fig:MSF-basico-1} e árvore correspondente~$T^\star$ do grafo.}
\label{fig:MSF-figura-2}
\end{figure}



Dado um grafo~$G$, um \defi{corte} é um conjunto de arestas cuja remoção aumenta o conjunto de componentes conexas de~$G$.
Dado $F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$, então existe um corte associado ao par $(F, uv)$ dado pela união de $uv$ com as arestas que reconectam as duas árvores geradas pela remoção de $uv$.


\begin{theorem}
\label{teo:cutset}
Seja~$G$ um grafo planar, $F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$, então o conjunto
$$
(F, uv)^\star := \{e^\star:e\in (F, uv)\}
$$
forma um ciclo em $G^\star$.
\end{theorem}


\section{Definição do problema}
\label{sec:definition-MSF}
O problema da floresta maximal de peso mínimo em grafos ponderados dinâmicos consiste na busca por uma implementação tão eficiente quanto possível para a seguinte biblioteca:

\begin{itemize}
\item \MSFCreate($n$): Cria e devolve um grafo plano ponderado~$G$ com $n$ vértices isolados.
\item \MSFaddEdge($G$, $u$, $v$, $e$, $w$): Insere uma nova aresta~$e$ com peso~$w$ ligando os vértices~$u$ e~$v$. Como o grafo~$G$ admite arestas paralelas, é necessário informar um identificador único~$e$ para a nova aresta inserida.
\item \MSFdelEdge($G$, $e$): Recebe um grafo plano ponderado~$G$ e uma aresta~$e$ de~$G$ e a remove do grafo.
\item \MSFupdate($G$, $e$, $w$): Altera o peso da aresta~$e$ do grafo dinâmico~$G$ para o valor~$w$.
\item \MSFweight($G$): Devolve o peso de uma MSF de $G$.
\end{itemize}


\begin{comment}
\section{Link-Cut Trees}
\label{sec:linkcuttree}

Para uma introdução sobre link-cut trees, recomendamos o trabalho de~\cite{linkcuttree}.

\begin{itemize}
\item \linkcutCreate(): Cria e retorna um novo nó de link-cut tree.
\item \linkcutAddEdge($v$, $w$): Adiciona uma aresta de~$v$ a~$w$, tornando~$v$ um filho de~$w$. Essa operação assume que~$v$ é a raiz de uma árvore~$T$ e que $w$ não é um nó de~$T$.
\item \linkcutDelEdge($v$): Remove a aresta de~$v$ para seu pai.
\item \linkcutEvert($v$): Torna~$v$ a raiz de sua árvore revertendo o caminho de~$v$ para a raiz original.
\item \linkcutMax($v$): Retorna o nó de peso máximo no caminho entre~$v$ e a raiz de sua árvore.
\item \linkcutMin($v$): Retorna o nó de peso mínimo no caminho entre~$v$ e a raiz de sua árvore.
\end{itemize}
\end{comment}

\section{Árvores planas de EITTWY}
Para resolver o problema da floresta maximal de peso mínimo para um grado plano conexo dinâmico, Eppstein et al.~\cite{EPPSTEIN-planar} propõem o uso de uma estrutura de dados que armazena, interligadamente, uma árvore geradora~$T$ de peso mínimo de~$G$ e a árvore dual~$T^\star$, que, pelo Teorema~\ref{teo:MSFdual}, é uma árvore geradora de peso máximo de~$G^\star$.

Na verdade, a estratégia dos autores aplica-se também a grafos desconexos, bastando usar a mesma estrutura para cada componente do grafo.

A ideia é basicamente usar Link-Cut trees para armazenar~$T$ e~$T^\star$.
Para manter a associação que há entre as arestas de~$G$ e~$G^\star$, as link cut Trees conterão também nós para representar as arestas de~$G$ e~$G^\star$.

Especificamente, cada aresta~$e$ de~$G$ corresponderá a quatro nós nas link-cut trees: dois da link-cut trees da link-cut tree de~$T$ e dois da link-cut tree de~$T^\star$.
Esses nós são chamados de $e_0$, $e_1$, $e_2$ e $e_3$, sendo $e_0$ e $e_2$ os nós da link cut tree de~$T$ e~$e_1$ e~$e_3$ da link-cut tree de~$T^\star$.
Se $e\in T$, então $e_0$ e $e_2$ estão conectados, senão $e_1$ e $e_3$ estão conectados na respectiva link-cut tree.

Além das árvores, as link-cut trees vão armazenar também informação sobre a imersão de~$G$.
Isso será feito da seguinte maneira.

\TODO{Completar com node path e ordem ciclica de $e_i$}

\begin{figure}[htb]
%\scalebox{2}{
\centering
\input{fig/MSF-basico-3}
%}
\caption{As árvores geradoras modificadas que representam o grafo da Figura~\ref{fig:MSF-basico-1}.}
\label{fig:MSF-figura-3}
\end{figure}



\section{Link-Cut Trees com ordem nas arestas}


\begin{itemize}
\item \LCOMakeNode(): Retorna o identificador único de um novo nó~$v$.
\item \LCOFindNode($s$): Recebe um sub-nó $s$ e retorna o identificador desse nó.
\item \LCOMerge($u$, $v$): Recebe dois nós $u$ e $v$ de mesmo peso e retorna um único nó~$w$ que é a união desses nós.
Se~$\alpha$ e~$\beta$ são respectivamente as listas ordenadas de arestas incidentes a~$u$ e a~$v$ seguindo a descrição combinatória plana, então $\alpha\beta$ é a lista de arestas incidentes a~$w$.
\item \LCOSplit($v$, $e$): Recebe um nó~$v$ e uma aresta~$e$ incidente a~$v$.
Corta o nó~$v$ em dois nós~$v'$ e~$v''$. Se $\alpha e\beta$ é a lista ordenada de arestas incidentes a~$v$, então $\alpha e$ e~$\beta$ são as listas ordenadas de arestas incidentes a~$v'$ e~$v''$, respectivamente.
\item \LCOLink($v$, $w$): Adiciona uma aresta de~$v$ a~$w$, tornando~$v$ um filho de~$w$. Essa operação assume que~$v$ é a raiz de uma árvore~$T$ e que $w$ não é um nó de~$T$.
\item \LCOCycle($v$, $e$): Permuta ciclicamente a ordem das arestas incidentes ao vértice~$v$ de forma que a aresta $e$ é a última na ordem. Se a ordem inicial tem forma $\alpha e \beta$, então a ordem resultante é $\beta\alpha e$.
\item \LCOLoop($v$): Recebe um identificador único de um nó e adiciona um laço a ele.
\item \LCOAddCost($v$, $w$): Recebe o identificador único de um nó e um novo peso~$w$ e atribui o peso~$w$ ao nó~$v$.
\end{itemize}

Manteremos duas tabelas hash:

\hashNP($v$): Recebe um vértice~$v$ e torna ponteiros para nós~$v_{first}$ e~$v_{last}$.

\hashEdges:\TODO{????}

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-4}
}
\caption{As árvores geradoras modificadas que representam o grafo da Figura~\ref{fig:MSF-basico-1}.}
\label{fig:MSF-figura-4}
\end{figure}


\section{Tratando mudança de peso de arestas}

Quando atualizamos o peso de uma aresta~$uv$ com a rotina \MSFupdate{} para um novo peso~$w$, cuja implementação pode ser vista no Algoritmo~\ref{Algo:MSFupdate}, precisamos garantir que a floresta~$F$ resultante continuará sendo  de peso mínimo.

Notemos que ou $uv\in F$ ou $uv^\star\in F^\star$, iremos tratar cada um desses casos separadamente.
A identificação de qual caso~$uv$ se encontra é feita na linha~\ref{Algo:MSFupdate:linhauvinF} do Algoritmo~\ref{Algo:MSFupdate}, para implementar essa consulta, não podemos fazer como foi feito linha~\ref{Algo:dymGraphReplace:linhayinTv} do \dymGraphReplace(Algoritmo~\ref{Algo:dymGraphReplace}), pois link-cut trees não possuem nós que representam arestas.
Portanto precisamos recorrer a recursos mais elaborados.
Manteremos um dicionário que guardará apontadores para os nós de~$F$ e usaremos como o conjunto de chaves os vértices de $G$. O apontador associado à chave~$u$ aponta para o nó que representa o vértice $u$.
Após usar esse dicionário para obter os nós que representam os vértices~$u$ e~$v$ usamos a rotina \linkcutPath{} para fazer o caminho entre~$u$ e~$v$ ser preferido e verificamos se~$u$ é predecessor ou sucessor de~$v$.

Se~$uv$ for uma aresta de~$F$ e se existir alguma aresta no corte~$(F, uv)$ com peso menor do que~$w$, então~$F$ não será mais de peso mínimo.
Para corrigir isso, precisamos tomar~$xy$ como a aresta de menor peso no corte~$(F, uv)$,
então remover~$uv$ de~$F$ e adicionar~$xy$ a~$F$.
Dessa forma, garantindo que~$F$ seja de peso mínimo.

Para obter a aresta~$xy$, vamos investigar o corte~$(F, uv)$.
Pelo Teorema~\ref{teo:cutset}, o conjunto~$(F, uv)^\star$ forma um ciclo em~$G^\star$.
Como~$uv^\star\in(F, uv)$ e~$uv$ é a única aresta de~$F$ cujo dual está em~$(F, uv)$, então as demais arestas desse corte formam um caminho em~$F^\star$ ligando os vértices incidentes a~$uv^\star$.
Utilizando a rotina \linkcutMin{}  da biblioteca de link-cut trees podemos obter o nó de menor peso nesse percurso.

Note também que, se modificarmos~$F$, então precisaremos atualizar~$F^\star$, removendo $xy^\star$ de~$F^\star$ e adicionando $uv^\star$ com o novo peso~$w$.

Se~$uv$ não for uma aresta de~$F$, então teremos que~$uv^\star$ é uma aresta de~$F^\star$.
O tratamento desse caso é análogo ao caso anterior e é feito entre as linhas~\ref{Algo:MSFupdate:dualinicio} e~\ref{Algo:MSFupdate:dualfim} do Algoritmo~\ref{Algo:MSFupdate}.

Como cada rotina de link-cut trees utilizada consome tempo~$\O{\lg n}$ amortizado, então o consumo de tempo de \MSFupdate{} também é~$\O{\lg n}$ amortizado.



\newpage
\MSFupdate($H$, $e$, $w$) recebe a hash $H$, uma aresta~$e$ e um peso~$w$ e atualiza o peso de $e$ para ser~$w$ e atualiza $T$ e~$T^\star$.

\begin{algorithm}[htb]
\caption{\MSFupdate($H$, $e$, $w$)}
\label{Algo:MSFupdate}
\begin{algorithmic}[1]
\State primal, $e_0$, $e_1$, $e_2$, $e_3$ $\gets$ $H$($e$)
\For {$i\in \{0,1,2,3\}$}
\State $e_i.w$ $\gets$ $w$
\EndFor
\If {primal}\label{Algo:MSFupdate:linhauvinF}
\State $\hat e_1$ $\gets$ \LCOFindNode($e_1$)
\State \LCOEvert($\hat e_1$)
\State $d$ $\gets$ \LCOMin($e_3$)\Comment{$d$ é identificador}

\State primal, $d_0$, $d_1$, $d_2$, $d_3$ $\gets$ $H$($d$)
\If {$d_0$.$w$ < $w$}
\State $\hat d$ $\gets$ \LCOFindNode($d_1$)
\State $\hat d_1$, $\hat d_3$ $\gets$ \LCOSplit($\hat d$, $\hat d$.first)\Comment{Remove $d$ de $T^\star$}
\State $\hat e$ $\gets$ \LCOFindNode($e_0$)
\State $\hat e_0$, $\hat e_2$ $\gets$ \LCOSplit($\hat e$, $\hat e$.first)\Comment{Remove $e$ de $T$}


\State $\hat d_0$ $\gets$ \LCOFindNode($d_0$)
\State $\hat d_2$ $\gets$ \LCOFindNode($d_2$)
\State $\hat d$ $\gets$ \LCOMerge( $\hat d_0$, $\hat d_2$)

\State $\hat e_3$ $\gets$ \LCOFindNode($e_3$)
\State $\hat e$ $\gets$ \LCOMerge( $\hat e_1$, $\hat e_3$)

\EndIf

\Else

\State $\hat e_0$ $\gets$ \LCOFindNode($e_0$)
\State \LCOEvert($\hat e_0$)
\State $d$ $\gets$ \LCOMax($e_2$)\Comment{$d$ é identificador}

\State primal, $d_0$, $d_1$, $d_2$, $d_3$ $\gets$ $H$($d$)
\If {$d_0$.$w$ > $w$}
\State $\hat d$ $\gets$ \LCOFindNode($d_0$)
\State $\hat d_0$, $\hat d_2$ $\gets$ \LCOSplit($\hat d$, $\hat d$.first)\Comment{Remove $d$ de $T$}
\State $\hat e$ $\gets$ \LCOFindNode($e_1$)
\State $\hat e_1$, $\hat e_3$ $\gets$ \LCOSplit($\hat e$, $\hat e$.first)\Comment{Remove $e$ de $T^\star$}


\State $\hat d_1$ $\gets$ \LCOFindNode($d_1$)
\State $\hat d_3$ $\gets$ \LCOFindNode($d_3$)
\State $\hat d$ $\gets$ \LCOMerge( $\hat d_1$, $\hat d_3$)

\State $\hat e_0$ $\gets$ \LCOFindNode($e_0$)
\State $\hat e_2$ $\gets$ \LCOFindNode($e_2$)
\State $\hat e$ $\gets$ \LCOMerge( $\hat e_0$, $\hat e_2$)




\EndIf
\EndIf
\end{algorithmic}
\end{algorithm}

\section{Implementação de \LCOSplice{} e \LCOMakeEdge{} com Link-Cut trees com ordem nas arestas}
\LCOMakeEdge(): Cria e retorna duas link cut trees tradicionais. A primeira representa uma aresta e a segunda o seu dual, como ilustrado na Figura~\TODO{bla}. Cada uma possui~$4$ nós.A aresta representada possui peso~$\infty$.


\LCOSplice{}


\begin{algorithm}[htb]
\caption{\LCOMakeEdge()}
\label{Algo:LCOMakeEdge}
\begin{algorithmic}[1]
\State $u$ $\gets$ \LCOMakeNode()
\State $v$ $\gets$ \LCOMakeNode()
\State $f$ $\gets$ \LCOMakeNode()
\State $e$ $\gets$ \LCOLink($u$, $v$)
\State \LCOLoop($f$)
\State \Return $u$, $e$, $v$ 
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[htb]
\caption{\LCOFindSubNode($v$, $e$)}
\label{Algo:LCOFindSubNode}
\begin{algorithmic}[1]
\If{ $e$ $\in$ $T$}
\State $v_{first}$, $v_{last}$ $\gets$ $H$($v$)
\State $e_{first}$, $e_{last}$ $\gets$ $H$($e$)
\State \linkcutEvert($v_{first}$)
\If{$e_{first}$.$parent$ $\neq$ $e_{last}$}
\State \Return $e_{first}$.$parent$
\EndIf
\State \Return $e_{last}$.$parent$
\Else
\If { \LCOFindNode($e_{first}.rot.parent$) $=$ $v$  }\Comment{$e_{first}$ e $e_{last}$ apontam pra $T^\star$}
\State \Return $e_{first}.rot.parent$
\Else
\State \Return $e_{last}.rot.parent$
\EndIf
\EndIf
\end{algorithmic}
\end{algorithm}

$v$, $u$, $e$, $d$ são identificadores
\begin{algorithm}[htb]
\caption{\LCOSplice($v$, $e$, $u$, $d$)}
\label{Algo:LCOSplice}
\begin{algorithmic}[1]
\State $s_v$ $\gets$ \LCOFindSubNode($v$, $e$)
\State $s_u$ $\gets$ \LCOFindSubNode($u$, $d$)
%\If {$v$ e $u$ em componentes conexas distintas}
%\State \LCOCycle($u$, $s_u$)
%\State \LCOCycle($v$, $s_v$)
%\State \LCOMerge($u$, $v$)
%\State $s_E$ $\gets$ $s_v$.$rot$
%\State $s_D$ $\gets$ $s_u$.$rot$
%\State $E$ $\gets$ \LCOFindNode($s_E$)
%\State $F$ $\gets$ \LCOFindNode($s_D$)
%\State \LCOCycle($E$, $s_E$)
%\State \LCOCycle($F$, $s_D$)
%\State \LCOMerge($E$, $F$)
%\State \Return
%\EndIf

\If {$v$ $=$ $u$}
\State \LCOCycle($v$, $s_v$)
\State \LCOSplit($u$, $s_u$)
\State $s_E$ $\gets$ $s_v$.$rot$
\State $s_D$ $\gets$ $s_u$.$rot$
\State $E$ $\gets$ \LCOFindNode($s_E$)
\State $F$ $\gets$ \LCOFindNode($s_D$)
\State \LCOCycle($E$, $s_E$)
\State \LCOCycle($F$, $s_D$)
\State \LCOMerge($E$, $F$)
%\Else
%\If{$e_v$ e $d_u$ não tem a mesma face esquerda}
%\State \Return
%\EndIf
%\State \LCOCycle($u$, $s_u$)
%\State \LCOCycle($v$, $s_v$)
%\State \LCOMerge($u$, $v$)

%\State $F$ $\gets$ \LCOFindNode($s_u$.$rot$)
%\State \LCOCycle($F$, \LCOFindNode($s_u$.$rot$)
%\State \LCOSplit($F$, \LCOFindNode($s_v$.$rot$  )
\EndIf
\end{algorithmic}
\end{algorithm}

\section{Resolvendo MSF dinâmico com \LCOSplice{} e \LCOMakeEdge{}}

\begin{algorithm}[htb]
\caption{\MSFaddEdge($v$, $e_v$, $u$, $e_u$)}
\label{Algo:MSFaddEdge}
\begin{algorithmic}[1]
\State $x$, $d$, $y$ $\gets$ \LCOMakeEdge()
\State \LCOSplice($v$, $e_v$, $x$, $d$)
\State \LCOSplice($u$, $e_u$, $y$, $d$)
\State \MSFupdate($f$, $w$)
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[htb]
\caption{\MSFdelEdge($e$, $d$)}
\label{Algo:MSFdelEdge}
\begin{algorithmic}[1]
\State $f$ $\gets$ \LCOMakeEdge()
\State \LCOSplice($e$,$e$)
\State \LCOSplice($d$,$d$)
\State \Return $e$.$id$ 
\end{algorithmic}
\end{algorithm}
