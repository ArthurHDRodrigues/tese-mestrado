\chapter{Floresta maximal de peso mínimo em grafos planos}
\label{sec:MSF}

O problema da floresta maximal de peso mínimo em grafos dinâmicos planos foi inicialmente apresentado na Seção~\ref{sec:Motivação} e é o segundo problema que iremos discutir.
O objetivo desse capítulo é apresentar o algoritmo de David Eppstein, Giuseppe Italiano, Roberto Tamassia, Robert Tarjan, Jeffery Westbrook e Moti Yung~\cite{EPPSTEIN-planar} que resolve esse problema para grafos planos que podem ter laços e arestas paralelas.

O estudo desse problema se inicia com uma revisão de conceitos de planaridade e dualidade apresentados nas Seções~\ref{sec:planaridade} e~\ref{sec:dualidade} respectivamente.
Esses conceitos são bem estabelecidos na literatura e essas seções são baseadas na Seção~4.2 do livro \textit{Graph Theory} de Reinhard Diestel~\cite{Diestel}.

Os conceitos apresentando nessas duas seções iniciais serão usados para definir formalmente o problema, o que é feito na Seção~\ref{sec:definition-MSF}, e para fundamentar a estrutura de dados que resolve esse problema, que será apresentada na Seção~\ref{sec:EODT}.

\section{Planaridade}
\label{sec:planaridade}

Intuitivamente, um grafo é dito plano se ele está desenhado em uma folha de papel de forma que suas arestas não se cruzem.
Formalmente, um \defi[grafo!plano]{grafo plano}~\cite{Diestel} é um par de conjuntos finitos $G = (V, E)$ com as seguintes propriedades:
\begin{enumerate}
\item $V\subset \R^2$;
\item Toda aresta é um arco entre dois vértices;
\item O interior de uma aresta não contém vértices nem intersecta outras arestas.
\end{enumerate}
Quando conveniente, $G$ será usado tanto para o par~$(V ,E)$ quanto para o conjunto~${V\cup\bigcup E}$.

Para cada grafo plano~$G$, ao remover~$G$ do plano~$\R^2$, é obtido um conjunto finito~$F(G)$ de regiões conexas que é chamado de \defi{conjunto de faces} de~$G$.
Naturalmente, cada uma dessas regiões é chamada de uma \defi{face} de $G$.
Uma dessas faces é ilimitada.
Essa face é chamada de \defi{face exterior}.
A Figura~\ref{fig:MSF-basico-0} mostra um grafo plano~$G$ e suas as faces.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-0.tex}
}
\caption{Um grafo ponderado plano e suas faces.}
\label{fig:MSF-basico-0}
\end{figure}



\begin{lemma}[Lemma 4.2.2~\cite{Diestel}]
\label{lemma:diestel}
Seja $G$ um grafo plano e $e$ uma de suas arestas.
\begin{enumerate}
\item Se $X$ é a fronteira de uma face de~$G$, então ou $e\subseteq X$ ou a intersecção de $X$ com o interior de $e$ é vazia.
\item Se $e$ pertence a um ciclo de $G$, então $e$ pertence à fronteira de exatamente duas faces distintas de $G$;
\item Se não existe ciclo que contém $e$, então $e$ pertence à fronteira de uma única face de~$G$.
\end{enumerate}
\end{lemma}

\begin{theorem}[Fórmula de Euler, Teorema 4.2.9~\cite{Diestel}]
\label{teo:MSFEuler}
Seja $G=(V,E)$ um grafo planar conexo com~$n$ vértices e~$m$ arestas. Toda imersão de~$G$ no plano possui o mesmo número $f$ de faces e
$$
n-m+f = 2.
$$
\end{theorem}

Para cada vértice $v$ de um grafo plano, é possível construir uma ordenação cíclica~$D(v)$ das aresta incidentes a~$v$~\cite{noma2003}.
Para obter essa ordenação, percorremos as arestas incidentes a~$v$ em sentido anti-horário até retornar à aresta inicial do percurso.
Uma aresta é dita \defi{sucessora} de outra aresta se a primeira é sucessora da segunda nesse percurso.
Uma lista de todas essas ordens cíclicas é chamada de~\defi{descrição combinatória plana} da imersão.

A descrição combinatória plana é essencialmente uma lista de adjacências do grafo plano em que a ordem das células é relevante.
Como estamos admitindo arestas paralelas, o número de ocorrências de um vértice~$u$ na lista de um vértice~$v$ será exatamente o número de arestas paralelas entre~$u$ e~$v$.
Um laço num vértice~$u$ corresponderá a duas ocorrências de~$u$ na sua lista de adjacências.

Para o algoritmo que vamos descrever nesse capítulo, cada aresta possui um identificador e armazenamos também nas células das listas o identificador das arestas.
Observe que cada aresta corresponde a duas células nas listas de adjacência do grafo:
Se os extremos de uma aresta são~$u$ e~$v$, há uma célula com~$u$ na lista de~$v$ e uma célula com~$v$ na lista de~$u$, ambos representando essa aresta.
Abaixo temos uma descrição combinatória plana do grafo da Figura~\ref{fig:MSF-basico-0}.
\begin{align*}
D(u)&=\langle (a,v), (b,v), (c,z))\rangle\\
D(v)&=\langle (a,u), (e,z), (b,u)  \rangle\\
D(z)&=\langle (e,v), (d,z), (d,z), (c,u)\rangle
\end{align*}

Pensamos nessas células como representações das duas possíveis orientações da aresta: de~$u$ para~$v$ (algumas vezes denotada por~$uv$) e de~$v$ para~$u$ (algumas vezes denotada por $vu$).
Essas duas células terão também um apontador~$\varname{sym}$, referenciando a outra e vice-versa.
%Ademais, cada uma dessas células possuirá também um campo $\varname{orig}$, que identificará o vértice a cuja lista pertence, ou seja, o vértice que é a origem da aresta orientada representada pela célula.

\section{Dualidade}
\label{sec:dualidade}


Dado um grafo plano~$G$, o grafo \defi{dual} de~$G$~\cite{Diestel} é o grafo $G^\star = (F,E^\star)$ cujo conjunto de vértices é o conjunto~$F = F(G)$ de faces de~$G$ e o conjunto de arestas $E^\star$ é construído a partir das arestas de~$G$.
Para cada aresta~$e\in E$, existe exatamente uma aresta~$e^\star$ no conjunto $E^\star$.
A aresta~$e^\star$ é chamada de \defi[aresta!dual]{aresta dual} de~$e$ e os vértices incidentes a essa aresta são as duas faces (não necessariamente distintas) cujas fronteiras contém~$e$.
Nesse contexto, chamamos~$G$ de grafo \defi{primal}.
Para ilustrar a relação entre cada aresta e seu dual, geralmente desenhamos cada aresta do grafo dual cruzando a correspondente aresta do grafo primal, como mostra a Figura~\ref{fig:MSF-basico-1}.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-1.tex}
}
\caption{Um grafo ponderado plano e seu dual.}
\label{fig:MSF-basico-1}
\end{figure}


Se~$G$ tem $n$ vértices e~$m$ arestas, o Teorema~\ref{teo:MSFEuler} mostra que o número de vértices do grafo dual é $\OTheta{n+m}$.

\begin{theorem}[\cite{EPPSTEIN-planar}]
\label{teo:MSFdual}
Seja~$T$ uma árvore geradora de um grafo plano conexo~$G$. O conjunto
$$
T^\star = \{e^\star:e\notin T\}
$$
é uma árvore geradora de~$G^\star$.
Além disso, se~$G$ for ponderado e adotarmos $w(e^\star) = w(e)$, então~$T$ será de peso mínimo se e somente se~$T^\star$ for de peso máximo e vice versa.
\end{theorem}

A Figura~\ref{fig:MSF-figura-2} mostra~$T$ e~$T^\star$ do grafo da Figura~\ref{fig:MSF-basico-1}.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-2}
}
\caption{Árvore geradora~$T$, em azul, de peso mínimo do grafo da Figura~\ref{fig:MSF-basico-1} e a árvore correspondente~$T^\star$ do grafo, em vermelho.}
\label{fig:MSF-figura-2}
\end{figure}





\section{Definição do problema}
\label{sec:definition-MSF}
O problema da floresta maximal de peso mínimo (MSF) em grafos dinâmicos planos ponderados consiste na busca por uma implementação tão eficiente quanto possível para a seguinte biblioteca:

\begin{itemize}
\item \MSFCreate($n$): Cria e devolve um grafo plano ponderado~$G$ com $n$ vértices isolados.
\item \MSFaddEdge($G$, $e$, $u$, $e_u$, $v$, $e_v$, $w$): Insere em~$G$ uma nova aresta~$e$ com peso~$w$ ligando os vértices~$u$ e~$v$. A nova aresta~$e$ é sucessora das arestas~$e_u$ e~$e_v$ nas ordenações cíclicas de~$u$ e~$v$, respectivamente.
\item \MSFdelEdge($G$, $e$): Remove a aresta~$e$ de~$G$.
\item \MSFupdate($G$, $e$, $w$): Altera o peso da aresta~$e$ de~$G$ para o valor~$w$.
\item \MSFweight($G$): Devolve o peso de uma MSF de $G$.
\end{itemize}


\section{Manutenção de MSF com árvores dinâmicas planas}

Para resolver o problema da floresta geradora de peso mínimo em grafos dinâmicos planos ponderados, Eppstein et al.~\cite{EPPSTEIN-planar} propuseram o uso de uma estrutura de dados que chamaremos de \defi[arvore@\'arvore!dinâmica plana]{árvores dinâmicas planas} (ADP). Originalmente os autores denominaram essa estrutura de \textit{edge ordered dynamic tree}.

%Seguindo a descrição de Eppstein et al.~\cite[Seção 3]{EPPSTEIN-planar}, essa estrutura consiste de árvores em que cada nó possui um peso, juntamente com uma descrição combinatória plana das árvores.
%Como árvores não possuem arestas paralelas, consideraremos, nas descrições abaixo, que a ordenação cíclica para cada nó~$u$ é simplesmente uma sequência dos nós vizinhos de~$u$ no sentido anti-horário.

Antes de descrever a biblioteca fornecida por ADPs, essa estrutura será detalhada nos próximos parágrafos junto a uma explicação de como utilizá-la para resolver o problema MSF.

Cada componente conexa do grafo plano dinâmico ponderado~$G$ é representada em um plano distinto.
Consequentemente, a face exterior de cada componente conexa é considerada distinta das faces exteriores das outras componentes.
Cada componente~$C$ de~$G$ é representada por duas árvores com pesos em seus vértices, sendo a primeira construída a partir de uma árvore geradora de peso mínimo~$T$ de~$C$ e a segunda a partir da correspondente dual~$T^\star$.
A Figura~\ref{fig:MSF-figura-3} ilustra essas duas árvores cuja construção será detalhada no próximo parágrafo.

A primeira dessas árvores, que é denotada por~$\hat T$, é essencialmente a árvore~$T$ submetida a duas transformações:
cada uma de suas arestas é subdivida; e é adicionada uma folha a cada vértice incidente a uma aresta de~$C$ que não esteja em~$T$.
Mais precisamente, $\hat T$ possui um vértice~$\hat v$, de peso~$-\infty$, para cada vértice~$v$ de~$C$, um vértice~$\hat e$, com o peso de $e$, para cada aresta~$e$ de~$T$ e dois vértices~$\hat d_0$ e~$\hat d_2$, ambos com o peso de~$d$, para cada aresta~$d$ tal que $d^\star$ está em~$T^\star$.
Se uma aresta~$e$ de~$T$ é incidente aos vértices~$v$ e~$u$ de~$C$, então o vértice~$\hat e$ é ligado aos vértices~$\hat v$ e~$\hat u$.
Se uma aresta~$d$ de~$C$ não está em~$T$ e é incidente aos vértices~$v$ e~$u$ de~$C$, então~$\hat d_0$ e~$\hat d_2$ são ligados a~$\hat v$ e~$\hat u$, respectivamente.
Note que~$\hat d_0$ e~$\hat d_2$ são folhas da árvore.

A segunda árvore, denotada por~$\hat T^\star$, possui construção análoga à primeira, mas é baseada em~$T^\star$ em vez de~$T$.
Ela possui um vértice~$\hat F$ para cada vértice~$F$ de~$C^\star$ (isto é, cada face de~$C$), um vértice~$\hat e^\star$ para cada aresta~$e^\star$ de $T^\star$ e dois vértices $\hat d_1$ e~$\hat d_3$ para cada aresta~$d$ de $T$.
O peso do vértice~$\hat F$ é $\infty$, enquanto que o peso de~$\hat e^\star$ é o peso de~$e$ e o peso de~$\hat d_1$ e~$\hat d_3$ é o peso de~$d$.
Se uma aresta $e^\star$ de $T^\star$ é incidente às faces~$F_1$ e~$F_2$ de~$C$, então o vértice~$\hat e^\star$ é ligado aos vértices~$\hat F_1$ e~$\hat F_2$.
Se uma aresta $d^\star$ de~$C^\star$ não está em $T^\star$ e é incidente às faces~$F_1$ e~$F_2$ de~$C$, então $\hat d_1$ e $\hat d_3$ são ligados a~$\hat F_1$ e~$\hat F_2$ respectivamente.
A Figura~\ref{fig:MSF-figura-3} ilustra~$\hat T$ e~$\hat T^\star$.

Note que há uma correspondência entre as arestas incidentes a um vértice~$v$ de~$G$ e os vértices vizinhos de~$\hat v$ em~$\hat T$.
Cada aresta~$e$ de $G$ corresponde a $\hat e$, $\hat d_0$ ou~$\hat d_2$. 
A descrição combinatória plana dessas duas árvores é herdada de~$C$ (ou seja, de~$G$) e de~$C^\star$.

\begin{figure}[htb]
%\scalebox{2}{
\centering
\input{fig/MSF-basico-3}
%}
\begin{tabular}{| c  c |} 
 \hline
 nós & pesos\\
 \hline
 $\hat a$, $\hat a_1$, $\hat a_3$ & 2 \\ 
 \hline
 $\hat b$, $\hat b_0$, $\hat b_2$ & 7 \\
 \hline
 $\hat c$, $\hat c_0$, $\hat c_2$ & 3 \\
 \hline
 $\hat d$, $\hat d_0$, $\hat d_2$ & 2 \\
 \hline
 $\hat e$, $\hat e_1$, $\hat e_3$ & 1 \\
 \hline
 $\hat u$, $\hat v$, $\hat z$ & $-\infty$ \\
 \hline
 $\hat F_0$, $\hat F_1$, $\hat F_2$, $\hat F_3$ & $\infty$ \\
 \hline
\end{tabular}
\caption{As árvores geradoras modificadas~$\hat T$ e~$\hat T^\star$ construídas a partir das árvores da Figura~\ref{fig:MSF-figura-2}.}
\label{fig:MSF-figura-3}
\end{figure}

A implementação de árvores dinâmicas planas utiliza link cut trees e árvores binárias de busca com chave implícita.

Cada vértice~$\hat v$ de~$\hat T$ e~$\hat T^\star$ é implementado por um conjunto de nós de link cut trees.
Esse conjunto possui um nó~$e_v$ para cada aresta~$e$ na ordem cíclica~$\langle e_1, e_2, \ldots, e_k\rangle$ de~$\hat v$.
Cada nó $e_v$ é ligado aos nós que representam a aresta sucessora e predecessora de~$e$ na ordem cíclica de~$\hat v$.
Com exceção de~$e_1$ e~$e_k$, que são ligados somente ao seu sucessor e predecessor, respectivamente.
Dessa forma, a ordem cíclica é representada por um percurso de nós de link cut tree.
Além disso, se a aresta~$e$ liga os nós~$\hat v$ e~$\hat u$, então~$e_v$ é ligado ao nó~$e_u$ que representa~$e$ na ordem cíclica de~$\hat u$.
A Figura~\ref{fig:MSF-figura-4} ilustra essas link cut trees.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-4}
}
\caption{Link cut trees que implementam $\hat T$ e $\hat T^\star$ ilustradas na Figura~\ref{fig:MSF-figura-3}.}
\label{fig:MSF-figura-4}
\end{figure}

Nessa construção há oito nós de link cut tree para cada aresta~$e$ de~$G$.
Os quatro primeiros, denotados por~$e_0$, $e_1$, $e_2$ e~$e_3$, representam~$e$.
Os nós $e_0$, $e_2$ são nós de~$\hat T$, enquanto que $e_1$, $e_3$ são nós de~$\hat T^\star$
Além disso, o nó $e_{i+1\mod 4}$ pertence à face a esquerda do nó $e_i$.
Os quatro últimos nós, denotados por~$v_0$, $v_1$, $v_2$ e~$v_3$, mantém a posição de~$e$ e~$e^\star$ nas ordens cíclicas.
Cada nó~$v_i$ é ligado ao nó~$e_i$.

Caso~$e$ seja uma aresta de~$T$, então o vértice~$\hat e$ de $\hat T$ é composto pelos nós~$e_0$ e~$e_2$.
Já os nós $e_1$, $e_3$ individualmente formam as duas folhas $\hat e_1$, $\hat e_3$ de $\hat T^\star$.

Caso~$d$ seja uma aresta de~$T^\star$, então o vértice~$\hat d$ de $\hat T^\star$ é composto pelos nós~$d_1$ e~$d_3$.
Já os nós $d_0$, $d_2$ individualmente formam as duas folhas $\hat d_0$, $\hat d_2$ de $\hat T$.

A sequência~$D(\hat v) = \langle e_1, e_2, \ldots, e_k\rangle$ também é armazenada em uma árvore binária de busca com chave implícita.
A ABB é utilizada para obter o primeiro e o último nó da ordem cíclica, o predecessor de um dado nó e identificar se dois nós estão na mesma ordem cíclica.
A raiz dessa ABB possui um campo $\node$ que armazena o identificador $v$.

Manteremos essas duas ADPs e uma tabela de símbolos $H$, que guarda o conjunto de óctuplas de nós $e_0$, $e_1$, $e_2$, $e_3$, $v_0$, $v_1$, $v_2$ e~$v_3$ e usa como chaves as arestas de~$G$.

Dessa forma, $G$ e uma floresta geradora maximal~$F$ de~$G$ de peso mínimo é representada por dois conjuntos de ADPs: o conjunto~$\hat F$ das ADPs das componentes de~$F$ e o conjunto~$\hat F^\star$ das ADPs do dual de cada componente de~$F$.

Antes de apresentar a biblioteca de ADPs, na próxima seção, vamos expandir a biblioteca de árvores binárias de busca com chave implícita, que foi inicialmente discutida no Capítulo~\ref{sec:TreapDeChaveImplicita} e introduzir link cut trees.


\section{Estruturas auxiliares}

Na próxima seção, a implementação das árvores dinâmicas planas será detalhada. Para construir essa estrutura de dados, são necessárias duas estruturas fundamentais: a primeira é a árvore binária de busca com chave implícita, discutida em detalhes no Capítulo~\ref{sec:TreapDeChaveImplicita} e a segunda são as link cut trees, que serão introduzidas na Seção~\ref{sec:linkcuttree}.



\subsection{Árvores binárias de busca com chave implícita}

\begin{itemize}
\item \treapSplitRight($\node$): corta a ABB que contém um nó~$\node$ em duas ABBs. A primeira ABB contém todos os nós com chave menor ou igual a chave de~$\node$ e a segunda contém todos os nós com chave estritamente maior do que a chave de~$\node$. Essa rotina retorna as raízes dessas duas ABBs.
\item \treapFirst($\node$): Retorna o nó de menor chave da ABB que contém $\node$.
\item \treapLast($\node$): Retorna o nó de maior chave da ABB que contém $\node$.
\end{itemize}

A implementação de \treapSplitRight{}, que pode ser vista no Algoritmo~\ref{Algo:TREAPsplitRight} é quase idêntica a de \treapSplit{}.
A única diferença entre essas rotinas é na linha~\ref{Algo:TREAPsplitRight:linha:atribuicao} em que atribuímos $\node$ a~$L$ ao invés de~$\node$.$esq$, como feito em \treapSplit{}.

\begin{algorithm}
\caption{\treapSplitRight($\node$)}
\label{Algo:TREAPsplitRight}
\begin{algorithmic}[1]
\State $R$ $\gets $ $\node$.$dir$
\State $L$ $\gets $ $\node$ \label{Algo:TREAPsplitRight:linha:atribuicao}
\State $tmp$ $\gets$ $\node$
\While { $tmp$.$pai$ $\neq \Nil$}
  \If { $tmp$.$pai$.$esq$ = $tmp$}
    \State $tmp$.$pai$.$esq$ $\gets$ $R$
    \State $tmp$.$pai$.$tam$ $\gets$ $tmp$.$pai$.$tam$ $\mathit{-}$ \treapGetSize($L$)
    \If { $R \neq \Nil$}
    \State $R$.$pai$ $\gets$ $tmp$.$pai$
    \EndIf
    \State $R$ $\gets$ $tmp$.$pai$
  \Else
    \State $tmp$.$pai$.$dir$ $\gets$ $L$ 
    \State $tmp$.$pai$.$tam$ $\gets$ $tmp$.$pai$.$tam$ $\mathit{-}$ \treapGetSize($R$)
    \If { $L$ $\neq$ \Nil}
    \State $L$.$pai$ $\gets$ $tmp$.$pai$
    \EndIf
    \State $L$ $\gets$ $tmp$.$pai$
  \EndIf
  \State $tmp$ $\gets$ $tmp$.$pai$
\EndWhile
\If { $L$ $\neq \Nil$} $L$.$pai$ $\gets\Nil$\EndIf
\If { $R$ $\neq \Nil$} $R$.$pai$ $\gets\Nil$\EndIf
\State $\node$.$dir$ $\gets $ $\node$.$esq$ $\gets$ $\node$.$pai$ $\gets$ $\Nil$
\State\Return $L$, $R$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{\treapFirst($\node$)}
\label{Algo:TREAPfirst}
\begin{algorithmic}[1]
\State $tmp$ $\gets$ $\node$
\While { $tmp$.$pai$ $\neq \Nil$}
  \State $tmp$ $\gets$ $tmp$.$pai$
\EndWhile

\While { $tmp$.$esq$ $\neq \Nil$}
  \State $tmp$ $\gets$ $tmp$.$esq$
\EndWhile

\State\Return $tmp$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{\treapLast($\node$)}
\label{Algo:TREAPfirst}
\begin{algorithmic}[1]
\State $tmp$ $\gets$ $\node$
\While { $tmp$.$pai$ $\neq \Nil$}
  \State $tmp$ $\gets$ $tmp$.$pai$
\EndWhile

\While { $tmp$.$dir$ $\neq \Nil$}
  \State $tmp$ $\gets$ $tmp$.$dir$
\EndWhile

\State\Return $tmp$
\end{algorithmic}
\end{algorithm}
\subsection{Link-Cut Trees}
\label{sec:linkcuttree}
Link-cut trees são uma estrutura de dados usada para representar e manipular florestas dinâmicas enraizadas.
Elas foram originalmente introduzidas por Sleator e Tarjan~\cite{SleatroTarjanLinkCutTree1983,} em~1983 e dão suporte às seguintes operações
\begin{itemize}
\item \linkcutCreate(): Cria e retorna um novo nó de link-cut tree.
\item \linkcutAddEdge($v$, $w$): Adiciona uma aresta de~$v$ a~$w$, tornando~$v$ um filho de~$w$. Essa operação assume que~$v$ é a raiz de uma árvore~$T$ e que $w$ não é um nó de~$T$.
\item \linkcutDelEdge($v$): Remove a aresta de~$v$ para seu pai.
\item \linkcutEvert($v$): Torna~$v$ a raiz de sua árvore revertendo o caminho de~$v$ para a raiz original.
\item \linkcutMax($v$): Retorna o nó de peso máximo no caminho entre~$v$ e a raiz de sua árvore.
\item \linkcutMin($v$): Retorna o nó de peso mínimo no caminho entre~$v$ e a raiz de sua árvore.
\item \linkcutMin($v$): Retorna o nó de peso mínimo no caminho entre~$v$ e a raiz de sua árvore.
\end{itemize}


Para uma introdução sobre link-cut trees, recomendamos o trabalho de~\cite{linkcuttree}.

\section{Biblioteca de árvores dinâmicas planas}
\label{sec:EODT}

Árvores dinâmicas planas dão suporte à biblioteca listada a seguir.
Para as descrições que se seguem, considere~$u$ e~$v$ vértices da árvore representada,
$p$ um nó da ordem cíclica~$D(u)$ e~$q$ um nó de~$D(v)$.

\begin{itemize}
\item \LCOMakeNode(): Cria e retorna um novo nó.
\item \LCOAddCost($p$, $w$): Atribui o peso~$w$ ao vértice que contém $p$ em sua ordem cíclica.
\item \LCOMax($p$, $q$): Retorna o vértice de peso máximo no percurso entre os nós~$p$ e~$q$.
Essa operação assume que $p$ e~$q$ são nós da mesma árvore.
\item \LCOMin($p$, $q$): Retorna o nó de peso mínimo no percurso entre os nós~$p$ e~$q$.
Essa operação assume que~$p$ e~$q$ são nós da mesma árvore.
\item \LCOConnected($p$, $q$): Retorna verdadeiro se os nós~$p$ e~$q$ estiverem na mesma árvore e falso caso contrário.
\item \LCOCycle($p$): Permuta ciclicamente $D(u)$ de forma que o nó~$p$ seja o último na ordem.
Se a ordem inicial tem forma $\alpha p \beta$, então a ordem resultante é $\beta\alpha p$.
\end{itemize}

É possível unir e separar nós dos ADPs com as rotinas \LCOMerge{} e \LCOSplit{}.

\begin{itemize}
\item \LCOMerge($p$, $q$): Recebe dois nós~$p$ e~$q$ de mesmo peso e une os vértices $u$ e $v$ que possuem $p$ e $q$ em suas ordens cíclicas.
Se~$\alpha$ e~$\beta$ são respectivamente as ordens cíclicas de~$u$ e~$v$, então $\alpha\beta$ será a ordem cíclica do vértice resultante. 
Essa operação assume que~$u$ e~$v$ estão em árvores distintas e na mesma face do grafo plano.
\item \LCOSplit($p$): Substitui o vértice~$u$ por dois vértices~$v$ e~$z$.
Considerando que a ordem cíclica $D(u)$ tem forma $\alpha p\beta$, então $\alpha p$ e~$\beta$ serão as ordens cíclicas de~$v$ e~$z$, respectivamente.
\item \LCOFindNode($p$): Recebe um nó $p$ e retorna o vértice que contêm $p$ em sua ordem cíclica.
\end{itemize}


A implementação dessas rotinas será apresentada na Seção~\ref{sec:implementacao-ADP}.


\section{Resolvendo MSF com ADPs}


A primeira rotina de MSF que vamos apresentar é \MSFupdate{}, cuja implementação pode ser vista no Algoritmo~\ref{Algo:MSFupdate}.
Para explicar seu funcionamento, utilizaremos a seguinte definição e resultado.

Dado um grafo~$G$, um \defi{corte} é um conjunto de arestas cuja remoção aumenta o conjunto de componentes conexas de~$G$.
Seja~$F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$.
Então existe um corte associado ao par $(F, uv)$ dado pela união de $uv$ com as arestas que reconectam as duas árvores geradas pela remoção de $uv$.

\begin{theorem}
\label{teo:cutset}
Seja~$G$ um grafo plano, $F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$.
Então o conjunto
$$
(F, uv)^\star := \{e^\star:e\in (F, uv)\}
$$
forma um ciclo em $G^\star$.
\end{theorem}

Quando atualizamos o peso de uma aresta~$e$ para um novo peso~$w$, precisamos eventualmente atualizar a floresta~$F$ de peso mínimo que está sendo mantida de forma que ela continue sendo maximal e de peso mínimo.

Se~$e$ for uma aresta de~$F$, é necessário verificar se não há alguma aresta no corte~$(F, e)$ com peso menor do que~$w$, pois se tal aresta existir, então~$F$ e~$F^\star$ não serão mais de peso mínimo em~$G$ e máximo em~$G^\star$, respectivamente.
Nesse caso, para corrigir isso, seja~$d$ uma aresta de menor peso no corte~$(F, e)$.
Então~$e$ é removida de~$F$ e $e^\star$ adicionada a~$F^\star$, e~$d^\star$ é removida de~$F^\star$ e $d$ é adicionada a~$F$.

Pelo Teorema~\ref{teo:cutset}, o conjunto~$(F, e)^\star$ forma um ciclo em~$G^\star$.
Como~$e^\star \in (F, e)^\star$ e~$e$ é a única aresta de~$F$ cuja aresta dual~$e^\star$ está em~$(F, e)^\star$, então as demais arestas desse corte formam um caminho em~$F^\star$ ligando os vértices~$F_1$ e~$F_2$ incidentes a~$e^\star$.

Dessa forma, na ADP~$T^\star$ de~$\hat F^\star$ que corresponde ao dual da componente de~$F$ que contém~$e$, cada aresta $d$ de menor peso em $(F, e)$ é representada por exatamente um nó que possui peso mínimo em~$\hat T^\star$.
Na verdade, para obter um nó $\hat d$ de menor peso nesse caminho, usaremos o caminho entre os nós $\hat e_1$ e $\hat e_3$ e a rotina \LCOMin{} da biblioteca de ADPs.
Isso é feito na linha~\ref{Algo:MSFupdate:linhamin} do Algoritmo~\ref{Algo:MSFupdate}.

As remoções de~$e$ de~$F$ e de~$d^\star$ de~$F^\star$ são feitas nas linhas~\ref{Algo:MSFupdate:linhasplitd} e~\ref{Algo:MSFupdate:linhasplite} do Algoritmo~\ref{Algo:MSFupdate} utilizando a rotina~\LCOSplit{}, que converte os nós~$\hat e$ e~$\hat d$ nos nós $\hat d_1$, $\hat d_3$, $\hat e_0$ e~$\hat e_2$, que se tornarão as novas folhas associadas às arestas~$e$ e~$d$.
Para adicionar as arestas~$e^\star$ a~$T^\star$ e $d$ a~$T$ são usadas as folhas~$\hat d_0$, $\hat d_2$, $\hat e_1$ e~$\hat e_3$ junto à rotina \LCOMerge{} nas linhas \ref{Algo:MSFupdate:linhas:Merged} e~\ref{Algo:MSFupdate:linhas:Mergee} do Algoritmo~\ref{Algo:MSFupdate}.

Se~$e$ não for uma aresta de~$F$, então~$e^\star$ é uma aresta de~$F^\star$.
O tratamento desse caso é análogo ao caso anterior e é feito entre as linhas~\ref{Algo:MSFupdate:dualinicio} e~\ref{Algo:MSFupdate:dualfim} do Algoritmo~\ref{Algo:MSFupdate}.

\begin{algorithm}[htb]
\caption{\MSFupdate($G$, $e$, $w$)}
\label{Algo:MSFupdate}
\begin{algorithmic}[1]
\State $e_0$, $e_1$, $e_2$, $e_3$, $v_0$, $v_1$, $v_2$, $v_3$ $\gets$ $H(e)$
\For {$i \in \{0,1,2,3\}$}
\State  \LCOAddCost($e_i$, $w$);
\EndFor

\If {\LCOFindNode($e_0$) $=$ \LCOFindNode($e_2$)}
\State $d$ $\gets$ \LCOMin($e_1$, $e_3$)\label{Algo:MSFupdate:linhamin}

\State $d_0$, $d_1$, $d_2$, $d_3$, $y_0$, $y_1$, $y_2$, $y_3$ $\gets$ $H(d)$
\If {$d_0$.$w$ < $w$}
\State \LCOSplit($d_1$)\label{Algo:MSFupdate:linhasplitd}
\State \LCOSplit($e_0$)\label{Algo:MSFupdate:linhasplite}


\State \LCOMerge($d_0$, $d_2$)\label{Algo:MSFupdate:linhas:Merged}
\State \LCOMerge($e_1$, $e_3$)\label{Algo:MSFupdate:linhas:Mergee}

\EndIf

\Else
\State $d$ $\gets$ \LCOMax($e_0$, $e_2$)\label{Algo:MSFupdate:dualinicio}

\State $d_0$, $d_1$, $d_2$, $d_3$, $y_0$, $y_1$, $y_2$, $y_3$ $\gets$ $H(d)$
\If {$d$.$w$ > $w$}
\State \LCOSplit($d_0$)
\State \LCOSplit($e_1$)

\State \LCOMerge($d_1$, $d_3$)
\State \LCOMerge($e_0$, $e_2$)

\EndIf
\EndIf\label{Algo:MSFupdate:dualfim}
\end{algorithmic}
\end{algorithm}


A próxima rotina elaborada é \MSFdelEdge{}, cuja implementação pode ser vista no Algoritmo~\ref{Algo:MSFdelEdge}.

Pelo Lema~\ref{lemma:diestel}, ou uma aresta~$e$ não está em ciclos em~$G$ e as duas faces incidentes a ela são a mesma, ou essas faces são distintas e a aresta está em pelo menos um ciclo em~$G$.

No primeiro caso, tratado entre as linhas~\ref{Algo:MSFdelEdge:linha3} e~\ref{Algo:MSFdelEdge:linha12} do Algoritmo~\ref{Algo:MSFdelEdge}, a remoção de~$e$ desconecta a componente~$C$ em que~$e$ se encontra.
Logo não há trabalho de manutenção em $\hat T$ além de remover~$\hat e$ de~$\hat T$, para fazer isso, é realizado 
duas chamadas de \LCOCycle{} seguidas de chamadas de \LCOSplit{}.
A face incidente a aresta~$e$ é a face exterior~$F$ de~$C$.
Como cada componente conexa está imersa em um plano distinto, a remoção de $e$ torna necessário dividir $\hat F$ em dois vértices, que representarão as duas faces exteriores das duas componentes conexas resultantes da remoção de~$e$.

No segundo caso, a remoção de~$e$ não desconecta sua componente~$C$.
Dessa forma, é necessário buscar uma substituta para $e$ caso essa aresta seja uma aresta de $T$.
Para fazer essa busca eficientemente, na linha~\ref{Algo:MSFdelEdge:linha:mudaPeso} do Algoritmo~\ref{Algo:MSFdelEdge}, o peso de~$e$ é mudado para~$\infty$, fazendo com que essa aresta se torne uma aresta de~$T^\star$. 
A remoção de $e$ implica na junção das duas faces distintas $F_0$ e $F_2$ incidentes a essa aresta.
Essa mesclagem é feita de forma que a descrição combinatória resultante se mantenha plana, isto é, se $\alpha e^\star \beta$ e $\gamma e^\star \delta$ forem as ordenações cíclicas de~$F_0$ e~$F_2$, respectivamente, então $\alpha \delta\gamma\beta$ é a ordenação cíclica da face resultante.

\begin{algorithm}[hbt]
\caption{\MSFdelEdge($G$, $e$)}
\label{Algo:MSFdelEdge}
\begin{algorithmic}[1]
\State $e_0$, $e_1$, $e_2$, $e_3$, $v_0$, $v_1$, $v_2$, $v_3$ $\gets$ $H_e(e)$
\If {\LCOFindNode($v_1$) $=$ \LCOFindNode($v_3$) }

\State \LCOCycle($v_0$) \label{Algo:MSFdelEdge:linha3}
\State \LCOSplit(\LCOPredecessor($v_0$))
\State \LCOCycle($v_2$)
\State \LCOSplit(\LCOPredecessor($v_2$))

\State \LCOCycle($v_1$)
\State $p_1$ $\gets$ \LCOPredecessor($v_1$)
\State \LCOSplit($p_1$)
\State \LCOCycle($v_3$)
\State \LCOSplit(\LCOPredecessor($v_3$))

\State \LCOSplit($p_1$) \label{Algo:MSFdelEdge:linha12}
\Else
\State \MSFupdate($G$, $e$, $\infty$)\label{Algo:MSFdelEdge:linha:mudaPeso}
\State \LCOCycle($v_0$)
\State \LCOSplit(\LCOPredecessor($v_0$))
\State \LCOCycle($v_2$)
\State \LCOSplit(\LCOPredecessor($e_2$))
\State \LCOCycle($v_1$)
\State \LCOSplit(\LCOPredecessor($v_1$))
\State \LCOCycle($v_3$)
\State \LCOSplit(\LCOPredecessor($v_3$))
\State \LCOMerge($v_1$, $v_3$)
\EndIf
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[htb]
\caption{\MSFaddEdge($G$, $e$, $u$, $f$, $v$, $g$, $w$)}
\label{Algo:MSFaddEdge}
\begin{algorithmic}[1]

\State $f_0$, $f_1$, $f_2$, $f_3$, $u_0$, $u_1$, $u_2$, $u_3$ $\gets$ $H(f)$
\State $g_0$, $g_1$, $g_2$, $g_3$, $v_0$, $v_1$, $v_2$, $v_3$ $\gets$ $H(g)$

\If {\LCOFindNode($u_0$) $=$ $u$}
  \State $i$ $\gets$ $0$
\Else
  \State $i$ $\gets$ $2$
\EndIf
\If {\LCOFindNode($v_0$) $=$ $v$}
  \State $j$ $\gets$ $0$
\Else
  \State $j$ $\gets$ $2$
\EndIf

\If{\LCOConnected($u$, $v$) e \LCOFindNode($v_{i+1}$) $\neq$ \LCOFindNode($u_{i+1}$)}
\State \Return Erro
\EndIf



\For {$i \in \{0,1,2,3\}$}
\State $s_i$ $\gets$ \LCOMakeNode(); $e_i$ $\gets$ \LCOMakeNode()
\State  \LCOAddCost($e_i$, $-\infty$);
\State \linkcutAddEdge($e_i$, $s_i$)
\EndFor
\State \LCOAddCost($s_0$, $-\infty$); \LCOAddCost($s_2$, $-\infty$);
\State \LCOAddCost($s_1$, $\infty$); \LCOAddCost($s_3$, $\infty$);
\State $H(e)$ $\gets$ $e_0$, $e_1$, $e_2$, $e_3$, $s_0$, $s_1$, $s_2$, $s_3$

\State \LCOCycle($u_i$)
\State \LCOMerge($u_i$, $s_0$)
\State \LCOCycle($v_j$)
\State \LCOMerge($v_j$, $s_2$)


\State \LCOCycle($u_{i+1}$)
\State \LCOMerge($u_{i+1}$, $s_1$)
\State \LCOCycle($v_{j+1}$)
\State \LCOMerge($v_{j+1}$, $s_3$)

\State \LCOMerge($e_0$, $e_2$)
\If{\LCOConnected($u$, $v$)}

\State \LCOSplit($u_{j+1}$)
\Else
\State \LCOMerge($u_{i+1}$, $v_{j+1}$)
\EndIf
\State \MSFupdate($G$, $e$, $w$)
\end{algorithmic}
\end{algorithm}

\section{Implementação de árvores dinâmicas planas}
\label{sec:implementacao-ADP}

As implementações de \LCOMakeNode{}, \LCOAddCost{}, \LCOMax{}, \LCOMin, \LCOFindNode{} são imediatas e são descritas nos Algoritmos~\ref{Algo:LCOMakeNode}, \ref{Algo:LCOAddCost}, \ref{Algo:LCOMax}, \ref{Algo:LCOMin} e~\ref{Algo:LCOFindNode}, respectivamente.

Na rotina \LCOMakeNode{} são criados um novo nó de link cut tree com a rotina \linkcutCreate{} e um novo nó~$T$ de ABB de chave implícita.
Então o campo~$\node$ de~$T$ é atribuído o novo nó de link cut tree, que é retornado em seguida.

\begin{algorithm}[htb]
\caption{\LCOMakeNode($p$, $q$)}
\label{Algo:LCOMakeNode}
\begin{algorithmic}[1]
\State $\node$ $\gets$ \linkcutCreate()
\State $T$ $\gets$ \treapCreate()
\State $T$.$\node$ $\gets$ $\node$
\State \Return $\node$
\end{algorithmic}
\end{algorithm}

Na rotina \LCOAddCost{} primeiro realiza um \linkcutEvert{} no último nó da ordem ciclica que contém~$p$.
Dessa forma, o caminho entre os nós \treapFirst($p$) e \treapLast($p$) coincide com a ordenação ciclica que contém esse nó.
Em seguida, a rotina \linkcutWeight{} que atribui o peso~$w$ para todos os nós entre \treapFirst($p$) e a raiz da sua árvore, isto é, \treapLast($p$).
Logo todos os nós da ordem cíclica que contém $p$ possuem seus pesos atualizados para o novo valor~$w$.

\begin{algorithm}[htb]
\caption{\LCOAddCost($p$, $w$)}
\label{Algo:LCOAddCost}
\begin{algorithmic}[1]
\State \linkcutEvert(\treapLast($p$))
\State \linkcutWeight(\treapFirst($p$), $w$)
\end{algorithmic}
\end{algorithm}

A implementação das rotinas \LCOMax{} e~\LCOMin{} são análogas.
Em ambas, é chamado \linkcutEvert($p$).
Em seguida, é atribui à variável~$m$ o valor de \linkcutMax($q$) (resp. \linkcutMin($q$)), que corresponde ao nó com maior (resp. menor) peso entre $q$ e a raiz da link cut tree, isto é, $p$.
Então é retornado o valor \LCOFindNode($m$).

\begin{algorithm}[htb]
\caption{\LCOMax($p$, $q$)}
\label{Algo:LCOMax}
\begin{algorithmic}[1]
\State \linkcutEvert($p$)
\State $m$ $\gets$ \linkcutMax($q$)
\State \Return \LCOFindNode($m$)
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[htb]
\caption{\LCOMin($p$, $q$)}
\label{Algo:LCOMin}
\begin{algorithmic}[1]
\State \linkcutEvert($p$)
\State $m$ $\gets$ \linkcutMin($q$)
\State \Return \LCOFindNode($m$)
\end{algorithmic}
\end{algorithm}

A implementação de \LCOFindNode{} é simples e usa a estrutura de árvores binárias de busca com chave implícita.
Dado o nó~$s$, sabemos que ele está em alguma ABB e que a raiz dessa árvore aponta para o nó que contém~$s$ em sua ordem cíclica,
logo usamos \treapGetRoot{} da biblioteca de ABBs para obter a raiz~$r$ da árvore e em seguida é retornado~$r$.$\node$.

\begin{algorithm}[htb]
\caption{\LCOFindNode($s$)}
\label{Algo:LCOFindNode}
\begin{algorithmic}[1]
\State $r$ $\gets$ \treapGetRoot($s$)
\State \Return $r$.$\node$
\end{algorithmic}
\end{algorithm}


A implementação da rotina \LCOMerge{} pode ser vista no Algoritmo~\ref{Algo:LCOMerge}.
O processo de \LCOMerge{} começa chamando a função \linkcutEvert{} invertendo a árvore de modo que o nó~\treapLast($p$) se torne a nova raiz.
Isso é necessário, pois a operação \linkcutAddEdge{} de adição de aresta subsequente assume que \treapLast($p$) é a raiz de sua árvore.
A função \linkcutAddEdge{} é usada para adicionar uma aresta entre~\treapLast($p$) e~\treapFirst($q$), conectando o último nó da ordem cíclica do vértice que contém~$p$ ao primeiro nó da ordem cíclica do nó que contém~$q$.
Para garantir que a ordem cíclica das arestas seja mantida corretamente, a função \treapJoin{} é chamada para unir as raízes das ABBs associadas aos vértices.

\begin{algorithm}[htb]
\caption{\LCOMerge($p$, $q$)}
\label{Algo:LCOMerge}
\begin{algorithmic}[1]
\State $l$ $\gets$ \treapLast($p$)
\State \linkcutEvert($l$)
\State \linkcutAddEdge($l$, \treapFirst($q$))
\State $T$ $\gets$ \treapJoin(\treapGetRoot($p$), \treapGetRoot($q$))
\State $T$.$\node$ $\gets$ $w$ \TODO{???}
\end{algorithmic}
\end{algorithm}

A implementação da rotina \LCOSplit($p$) pode ser visto no Algoritmo~\ref{Algo:LCOSplit}.
Essa rotina realiza a divisão do vértice~$v$ cuja ordem cíclica contém~$p$ em dois novo vértices, de acordo com a ordem cíclica das arestas incidentes ao vértice~$v$.

Primeiro, a função \linkcutEvert{} é aplicada para fazer uma inversão em \treapLast($p$), assim o caminho entre \treapFirst($p$) e a raiz corresponde a ordem cíclica de $v$.
Dessa forma \linkcutParent($p$) retorna o sucesso do nó $p$ na ordem cíclica, que é armazenado na variável~$y$ e ao aplicar \linkcutDelEdge($p$) a ordem cíclica de~$v$ é dividida em duas sequências, a primeira de \treapFirst($p$) até $p$ e a segunda de~$y$ até~\treapLast($p$).
Essa sequências correspondem às ordens cíclicas dos vértices resultantes desejados.
Finalmente, a árvore binária de busca que contém o nó~$p$ é então dividida em duas partes: uma que mantém a ordem das arestas até $p$, e outra que contém o restante.

\begin{algorithm}[htb]
\caption{\LCOSplit($p$)}
\label{Algo:LCOSplit}
\begin{algorithmic}[1]
\State \linkcutEvert(\treapLast($p$))
\State $y$ $\gets$ \linkcutParent($p$)
\State \linkcutDelEdge($p$)
\State $T$, $T'$ $\gets$ \treapSplitRight($p$)
\State $T$.$\node$ $\gets$ $w$\TODO{???}
\State $T'$.$\node$ $\gets$ $v$\TODO{???}
\end{algorithmic}
\end{algorithm}


A implementação da rotina \LCOCycle($\hat u$, $\hat e$) pode ser visto no Algoritmo~\ref{Algo:LCOCycle}.

O processo começa comparando~$p$ com o último nó da ordem cíclica, caso esses nós sejam iguais, então a função termina imediatamente.
Caso contrário, a função \linkcutEvert{} é aplicada a \treapLast($p$) para reverter a ordem do caminho que vai até a raiz.
Essa operação faz com que o pai de $p$ seja o sucessor desse nó na ordem cíclica.
Então é usado a rotina \linkcutParent{} para obter esse sucessor~$x$ e remove a aresta que liga~$p$ a~$x$.
Em seguida, a função \linkcutAddEdge adiciona uma nova aresta que conecta o último nó da ordem cíclica ao primeiro nó dessa ordem, efetivamente ajustando a ordem cíclica.
Finalmente, a árvore binária de busca associada é dividida em partes, reorganizadas, e depois unidas para representar a nova ordem cíclica, garantindo que~$p$ seja, de fato, o último nó na sequência cíclica.


\begin{algorithm}[htb]
\caption{\LCOCycle($p$)}
\label{Algo:LCOCycle}
\begin{algorithmic}[1]
\State $l$ $\gets$ \treapLast($p$)
\If{$l$ $=$ $p$}
\State\Return
\EndIf
\State \linkcutEvert($l$)
\State $x$ $\gets$ \linkcutParent($p$)
\State \linkcutDelEdge($p$)
\State \linkcutAddEdge($l$, \treapFirst($p$))
\State $T$, $T'$ $\gets$ \treapSplitRight($p$)
\State $T$ $\gets$ \treapJoin($T'$, $T$)
\State $T$.$\node$ $\gets$ $p$
\end{algorithmic}
\end{algorithm}
