\chapter{Floresta maximal de peso mínimo em grafos planos}
\label{sec:MSF}

O problema da floresta maximal de peso mínimo em grafos dinâmicos foi inicialmente apresentado na Seção~\ref{sec:Motivação} e é o segundo problema que iremos discutir.
Nesse capítulo, vamos apresentar o algoritmo de David Eppstein, Giuseppe Italiano, Roberto Tamassia, Robert Tarjan, Jeffery Westbrook e Moti Yung~\cite{EPPSTEIN-planar} para esse problema.
O algoritmo se aplica a grafos planares arbitrários porém, por simplicidade, em nossa exposição, nos restringiremos a grafos planares conexos.
Começamos visitando conceitos de planaridade e dualidade.


\section{Planaridade}

Intuitivamente, um grafo é dito \defi[grafo!planar]{planar}~\cite{planarTheoryAlgorith} se é possível desenhá-lo no plano de forma que suas arestas não se cruzem e um grafo \defi[grafo!plano]{plano} é um grafo planar já desenhado no plano.

Formalmente, uma \defi{imersão no plano} de um grafo~$G=(V,E)$ é um par de funções \nolbreaks{$\phi_V:V\mapsto \R^2$} e $\phi_E: E\times [0,1]\mapsto \R^2$ tais que:
\begin{enumerate}
\item $\phi_V$ é injetora; 
\item $\phi_E(uv,0) = \phi_V(u)$ e $\phi_E(uv,1) = \phi_V(v)$, para toda aresta $uv\in E$;
\item $\phi_E(uv)$ é uma curva sem auto-intersecção.
\end{enumerate}
Usaremos somente $\phi$ para nos referirmos ao par $(\phi_V,\phi_E)$.

Um grafo~$G=(V,E)$ é dito \defi{planar}~\cite{noma2003} se existir imersão de~$G$ no plano tal que
\begin{enumerate}
\item A imagem das arestas não contém imagens dos vértices no seu interior, ou seja, $\phi_E(uv,x) \neq \phi_V(w)$, para toda aresta $uv\in E$, vértice $w\in V$ e número real~$x$ tal que $0<x<1$;
\item As curvas associadas a quaisquer duas arestas distintas não se cruzam no seu interior, ou seja, $\phi_E(uv,x)\neq \phi_E(wz,y)$ para toda aresta $uv,wz\in E$ e $0<x,y<1$ números reais.
\end{enumerate}
Um grafo planar junto com uma imersão fixada é chamado de grafo \defi{plano}.

Dado um grafo plano~$G$ com imersão~$\phi$, se removermos a imagem de $\phi$ do plano obteremos regiões conexas chamadas de \defi{faces}~\cite{planarTheoryAlgorith}.
Uma dessas faces é ilimitada.
Essa face é chamada de \defi{face exterior}.
A Figura \TODO{1} mostra as faces de um grafo plano.

\TODO{FIGURA 1}

\begin{theorem}[Fórmula de Euler]
\label{teo:MSFEuler}
Seja $G=(V,E)$ um grafo planar conexo com~$n$ vértices e~$m$ arestas. Toda imersão de~$G$ no plano possui o mesmo número $f$ de faces e
$$
n-m+f = 2.
$$
\end{theorem}

Para cada vértice $v$ de um grafo plano, é possível construir uma ordenação cíclica~$D(v)$ das aresta incidentes a~$v$~\cite{noma2003}.
Para obter essa ordenação, percorremos as arestas incidentes a~$v$ em sentido horário até retornar à aresta inicial do percurso.
Uma aresta $vu$ é \defi{sucessora} de uma aresta $vw$ se a primeira é sucessora da segunda nesse percurso.
Uma lista de todas essas ordens cíclicas é chamada de~\defi{descrição combinatória plana} da imersão.
A Tabela \TODO{bla} mostra as ordenações de cada vértice do grafo da Figura \TODO{bla}.

É possível obter uma descrição combinatória plana em tempo linear~\TODO{Citar fonte}.

Dado um grafo plano~$G$ e uma descrição combinatória~$D$ de uma imersão de~$G$, um \defi{ciclo facial} de~$D$ é um ciclo~$v_0,v_1,\ldots,v_{k-1},v_0$ onde $v_iv_{i+1}$ é sucessor de $v_iv_{i-1}$ em $D(v_i)$.
A Figura \TODO{bla} mostra alguns ciclos faciais do grafo da Figura \TODO{bla}.

\section{Dualidade}

Se~$G$ é um grafo plano conexo, para cada face~$F_i$, existe um único percurso fechado de~$G$ cuja remoção de sua imagem de~$\phi$ corta o plano em duas regiões conexas.
Uma delas correspondendo a~$F_i$ e outra sendo todo o restante do plano.
A \defi{fronteira} de uma face é o conjunto de arestas pertencentes a esse percurso.
Por exemplo, na Figura~\TODO{1} a imagem de~$\phi$ do percurso \TODO{bla-bla-bla} delimita~\TODO{$F_?$} do restante do plano, logo a fronteira da face~\TODO{$F_?$} é o conjunto de arestas~\TODO{\{blablabla\}}.

Dado um grafo plano, ou seja, um grafo planar~$G=(V,E)$ e uma imersão~$\phi$ desse grafo, o grafo \defi{dual} de~$G$~\cite{planarTheoryAlgorith} é o grafo $G^\star = (F,E^\star)$ cujo conjunto de vértices é o conjunto~$F$ de faces da imersão~$\phi$ e o conjunto de arestas $E^\star$ é construido a partir das arestas de~$G$.
Para cada aresta~$e\in E$, existe exatamente uma aresta~$e^\star$ no conjunto $E^\star$.
A aresta~$e^\star$ é chamada de \defi{aresta dual} de~$e$ e os vértices incidentes a essa aresta são as duas faces (não necessariamente distintas) cujas fronteiras contém~$e$.
Nesse contexto, chamamos~$G$ de grafo \defi{primal}.
Para ilustrar a relação entre cada aresta e seu dual, geralmente desenhamos cada aresta do grafo dual cruzando a correspondente aresta do grafo primal, como mostra a Figura \TODO{2}.
Note que o grafo dual pode conter arestas paralelas, assim como laços.

\TODO{FIGURA 2}


O Teorema~\ref{teo:MSFEuler} mostra que o número de vértices do grafo dual é $\OTheta{n}$.
\TODO{pq? quanto vale $m$?}

\begin{theorem}
\label{teo:MSFdual}
Seja~$T$ uma árvore geradora de um grafo planar~$G$. O conjunto
$$
T^\star = \{e^\star:e\notin T\}
$$
é uma árvore geradora de~$G^\star$.
Além disso, se~$G$ for ponderado e adotarmos $w(e^\star) = w(e)$, então~$T$ será de peso mínimo se e somente se~$T^\star$ for de peso máximo e vice versa.
\end{theorem}

A Figura \TODO{3} mostra $T$ e $T^\star$ de uma versão ponderada do grafo da Figura \TODO{2}

\TODO{FIGURA 3}


\section{Link-Cut Trees}
\label{sec:linkcuttree}

Para uma introdução sobre link-cut trees, recomendamos o trabalho de~\cite{linkcuttree}.

Biblioteca de link-cut tree:
\begin{itemize}
\item \linkcutCreate($n$): recebe um vértice e devolve um nó de link/cut tree que representa esse vértice.
\item \linkcutAddEdge($F$, $u$, $v$, $w$): Adiciona a aresta~$uv$ com peso~$w$ à floresta~$F$.
\item \linkcutDelEdge($F$, $u$, $v$): Remove a aresta~$uv$ de~$F$.
\item \linkcutQuery($F$, $u$, $v$): Realiza uma consulta de conexidade entre os vértices~$u$ e~$v$.
\item \linkcutMax($F$, $u$, $v$): Retorna o nó com peso máximo no caminho entre~$u$ e~$v$ na floresta~$F$.
\item \linkcutMin($F$, $u$, $v$): Retorna o nó com peso mínimo no caminho entre~$u$ e~$v$ na floresta~$F$.
\item \linkcutPath($F$, $u$, $v$): Faz o caminho entre $u$ e $v$ ser o preferido.
\end{itemize}

\section{Texto antigo}

Ele consiste na busca por uma implementação tão eficiente quanto possível para a seguinte biblioteca:

\begin{itemize}
\item \MSFCreate($G_0$): recebe um grafo plano ponderado~$G_0$ dado por listas de adjacências e devolve um grafo dinâmico plano ponderado isomorfo a~$G_0$; \TODO{Para cada aresta~$uv$ em~$G_0$ também é informado a aresta dual~$uv^\star$, dessa forma fixando uma imersão no plano.}
\item \MSFupdate($G$, $u$, $v$, $w$): atribui o peso~$w$ à aresta~$uv$ do grafo dinâmico~$G$.
\item \MSFweight($G$): devolve o peso de uma MSF de $G$.
\end{itemize}


\section{Subdivisão planar e suas representações}


Dado um grafo~$G$, um \defi{corte} é um conjunto de arestas cuja remoção aumenta o conjunto de componentes conexas de~$G$.
Dado $F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$, então existe um corte associado ao par $(F, uv)$ dado pela união de $uv$ com as arestas que reconectam as duas árvores geradas pela remoção de $uv$.


\begin{theorem}
\label{teo:cutset}
Seja~$G$ um grafo planar, $F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$, então o conjunto
$$
(F, uv)^\star := \{e^\star:e\in (F, uv)\}
$$
forma um ciclo em $G^\star$.
\end{theorem}


\section{Ideia do algoritmo}
Para um grafo dinâmico~$G$, manteremos uma floresta maximal de pesos mínimos~$F$ e sua floresta dual~$F^\star$ como definida no Teorema~\ref{teo:MSFdual} usando link-cut trees.
Construiremos~$F$ e~$F^\star$ na rotina \MSFCreate($G_0$), cuja implementação está detalhada no Algoritmo~\ref{Algo:MSFCreate}.
Nessa rotina, primeiro usaremos a rotina auxiliar~\order{} para ordenar as arestas de~$G_0$ em ordem crescente de peso e retornar uma lista com essas arestas ordenadas.
Lembramos que~$G_0$ mantém, para cada aresta~$uv$, sua aresta dual~$uv^\star$, dessa forma, para não perder essa informação, faremos com que cada entrada da lista retornada por~\order{}
possua ponteiros para~$uv$, seu peso~$w$ e~$uv^\star$.

Em seguida percorreremos essa lista sequencialmente e para cada aresta~$uv$ nela, faremos um teste de conexidade entre os vértices~$u$ e~$v$.
Se~$u$ e~$v$ não estiverem conectados, então inserimos~$uv$ em~$F$ com peso~$w$, caso contrário inserimos $uv^\star$ em~$F^\star$ com o mesmo peso~$w$.

Como inserimos as arestas em ordem crescente de peso, a floresta~$F$ é de pesos mínimos e logo, pelo Teorema~\ref{teo:MSFdual}, $F^\star$ é de pesos máximos.

\begin{algorithm}[htb]
\caption{\MSFCreate($n$, $G_0$)}
\label{Algo:MSFCreate}
\begin{algorithmic}[1]
\State \varname{lista} $\gets$ \order($G_0$)
\For{$uv$ em \varname{lista}}\label{Algo:MSFCreate:linhafor}
\If \linkcutQuery($F$, $u$, $v$)\label{Algo:MSFCreate:query}
\State \linkcutAddEdge($G$.$F^\star$, $e$, $f$, $w$)\label{Algo:MSFCreate:link1}
\Else
\State \linkcutAddEdge($G$.$F$, $u$, $v$, $w$)\label{Algo:MSFCreate:link2}
\EndIf
\EndFor
\State \Return $G$
\end{algorithmic}
\end{algorithm}

Existem diversos algoritmos conhecidos na literatura que podem implementar a rotina \order{}~\cite{CLRS} com consumo de tempo~$\O{m\lg m}$, onde $m$ é o tamanho da lista,
que, no nosso caso, coincide com o número de arestas do grafo~$G_0$.
O laço da linha~\ref{Algo:MSFCreate:linhafor} do Algoritmo~\ref{Algo:MSFCreate} itera~$m$ vezes e cada teste de conexidade da linha~\ref{Algo:MSFCreate:query} e cada chamada para a rotina  \linkcutAddEdge{} nas linhas~\ref{Algo:MSFCreate:link1} e~\ref{Algo:MSFCreate:link2} possuem consumo de tempo~$\O{\lg n}$, onde~$n$ é o número de vértices do grafo.
Logo o consumo de tempo de \MSFCreate{} é $\O{m\lg n}$.

Para implementar \MSFweight{} faremos com que cada nó das link-cut trees tenha um campo~$w$ que contabiliza o peso total da subárvore enraizada naquele nó.
Dessa forma, para obter o peso da floresta maximal de peso mínimo~$F$ que estamos mantendo, basta retornar o campo $w$ da raiz de~$F$.
Essa rotina consome tempo constante.

\begin{algorithm}[htb]
\caption{\MSFweight($G$)}
\label{Algo:MSFweight}
\begin{algorithmic}[1]
\State \Return $G$.$F$.$w$
\end{algorithmic}
\end{algorithm}

Quando atualizamos o peso de uma aresta~$uv$ com a rotina \MSFupdate{} para um novo peso~$w$, cuja implementação pode ser vista no Algoritmo~\ref{Algo:MSFupdate}, precisamos garantir que a floresta~$F$ resultante continuará sendo  de peso mínimo.

Notemos que ou $uv\in F$ ou $uv^\star\in F^\star$, iremos tratar cada um desses casos separadamente.
A identificação de qual caso~$uv$ se encontra é feita na linha~\ref{Algo:MSFupdate:linhauvinF} do Algoritmo~\ref{Algo:MSFupdate}, para implementar essa consulta, não podemos fazer como foi feito linha~\ref{Algo:dymGraphReplace:linhayinTv} do \dymGraphReplace(Algoritmo~\ref{Algo:dymGraphReplace}), pois link-cut trees não possuem nós que representam arestas.
Portanto precisamos recorrer a recursos mais elaborados.
Manteremos um dicionário que guardará apontadores para os nós de~$F$ e usaremos como o conjunto de chaves os vértices de $G$. O apontador associado à chave~$u$ aponta para o nó que representa o vértice $u$.
Após usar esse dicionário para obter os nós que representam os vértices~$u$ e~$v$ usamos a rotina \linkcutPath{} para fazer o caminho entre~$u$ e~$v$ ser preferido e verificamos se~$u$ é predecessor ou sucessor de~$v$.

Se~$uv$ for uma aresta de~$F$ e se existir alguma aresta no corte~$(F, uv)$ com peso menor do que~$w$, então~$F$ não será mais de peso mínimo.
Para corrigir isso, precisamos tomar~$xy$ como a aresta de menor peso no corte~$(F, uv)$,
então remover~$uv$ de~$F$ e adicionar~$xy$ a~$F$.
Dessa forma, garantindo que~$F$ seja de peso mínimo.

Para obter a aresta~$xy$, vamos investigar o corte~$(F, uv)$.
Pelo Teorema~\ref{teo:cutset}, o conjunto~$(F, uv)^\star$ forma um ciclo em~$G^\star$.
Como~$uv^\star\in(F, uv)$ e~$uv$ é a única aresta de~$F$ cujo dual está em~$(F, uv)$, então as demais arestas desse corte formam um caminho em~$F^\star$ ligando os vértices incidentes a~$uv^\star$.
Utilizando a rotina \linkcutMin{}  da biblioteca de link-cut trees podemos obter o nó de menor peso nesse percurso.

Note também que, se modificarmos~$F$, então precisaremos atualizar~$F^\star$, removendo $xy^\star$ de~$F^\star$ e adicionando $uv^\star$ com o novo peso~$w$.

Se~$uv$ não for uma aresta de~$F$, então teremos que~$uv^\star$ é uma aresta de~$F^\star$.
O tratamento desse caso é análogo ao caso anterior e é feito entre as linhas~\ref{Algo:MSFupdate:dualinicio} e~\ref{Algo:MSFupdate:dualfim} do Algoritmo~\ref{Algo:MSFupdate}.

Como cada rotina de link-cut trees utilizada consome tempo~$\O{\lg n}$ amortizado, então o consumo de tempo de \MSFupdate{} também é~$\O{\lg n}$ amortizado.


\begin{algorithm}[htb]
\caption{\MSFupdate($G$, $u$, $v$, $w$)}
\label{Algo:MSFupdate}
\begin{algorithmic}[1]
\State $e$,$f$ $\gets$ $uv^\star$
\If {$uv$ $\in$ $G$.$F$}\label{Algo:MSFupdate:linhauvinF}

\State \varname{min} $\gets$ \linkcutMin($F^\star$, $e$, $f$)
\If {$\varname{min}$.$w$ > $w$}
\State \linkcutDelEdge($F$, $u$, $v$)
\State \linkcutAddEdge($F$, $u$, $v$, $w$)
\Else
\State $x$,$y$ $\gets$ \varname{min}
\State \linkcutDelEdge($F^\star$, $x$, $y$)
\State \linkcutAddEdge($F^\star$, $e$, $f$, $w$)
\State $x$,$y$ $\gets$ $\varname{min}^\star$
\State \linkcutDelEdge($F$, $u$, $v$)
\State \linkcutAddEdge($F$, $x$, $y$, \varname{min}.$w$)
\EndIf

\Else

\State \varname{max} $\gets$ \linkcutMax($F$, $u$, $v$)\label{Algo:MSFupdate:dualinicio}
\If {\varname{max}.$w$  < $w$}
\State \linkcutDelEdge($F^\star$, $e$, $f$)
\State \linkcutAddEdge($F^\star$, $e$, $f$, $w$)
\Else
\State $x$,$y$ $\gets$ \varname{max}
\State \linkcutDelEdge($F$, $x$, $y$)
\State \linkcutAddEdge($F$, $u$, $v$, $w$)
\State $x$,$y$ $\gets$ $\varname{max}^\star$
\State \linkcutDelEdge($F^\star$, $e$, $f$)
\State \linkcutAddEdge($F^\star$, $x$, $y$, \varname{max}.$w$)\label{Algo:MSFupdate:dualfim}
\EndIf

\EndIf
\end{algorithmic}
\end{algorithm}
