\chapter{Floresta maximal de peso mínimo em grafos planos}
\label{sec:MSF}

O problema da floresta maximal de peso mínimo em grafos dinâmicos foi inicialmente apresentado na Seção~\ref{sec:Motivação} e é o segundo problema que iremos discutir.
Nesse capítulo, vamos apresentar o algoritmo de David Eppstein, Giuseppe Italiano, Roberto Tamassia, Robert Tarjan, Jeffery Westbrook e Moti Yung~\cite{EPPSTEIN-planar} que resolve esse problema para grafos que podem ter laços e arestas paralelas.

Começaremos o estudo desse problema com uma revisão de conceitos de planaridade e dualidade apresentados nas Seções~\ref{sec:planaridade} e~\ref{sec:dualidade}, respectivamente.
Esses conceitos serão usados para definir formalmente o problema, que é feito na Seção~\ref{sec:definition-MSF}, e para fundamentar a estrutura de dados que resolve esse problema, que será apresentada na Seção~\ref{sec:definition-MSF}.


  pelas estruturas de dados 

%O algoritmo se aplica a grafos planares arbitrários porém, por simplicidade, em nossa exposição, nos restringiremos a grafos planares conexos.

\section{Planaridade}
\label{sec:planaridade}

Intuitivamente, um grafo é dito \defi[grafo!planar]{planar}~\cite{planarTheoryAlgorith} se é possível desenhá-lo no plano de forma que suas arestas não se cruzem e um grafo \defi[grafo!plano]{plano} é um grafo planar já desenhado no plano.

Formalmente, uma \defi{imersão no plano} de um grafo~$G=(V,E)$ é um par de funções \nolbreaks{$\phi_V:V\mapsto \R^2$} e $\phi_E: E\times [0,1]\mapsto \R^2$ tais que:
\begin{enumerate}
\item $\phi_V$ é injetora; 
\item $\phi_E(uv,0) = \phi_V(u)$ e $\phi_E(uv,1) = \phi_V(v)$, para toda aresta $uv\in E$;
\item $\phi_E(uv)$ é uma curva sem auto-intersecção.
\end{enumerate}
Usaremos somente $\phi$ para nos referirmos ao par $(\phi_V,\phi_E)$.

Um grafo~$G=(V,E)$ é dito \defi{planar}~\cite{noma2003} se existir imersão de~$G$ no plano tal que
\begin{enumerate}
\item A imagem das arestas não contém imagens de vértices no seu interior, ou seja, $\phi_E(uv,x) \neq \phi_V(w)$, para toda aresta $uv\in E$, vértice $w\in V$ e número real~$x$ tal que $0<x<1$;
\item As curvas associadas a quaisquer duas arestas distintas não se cruzam no seu interior, ou seja, $\phi_E(uv,x)\neq \phi_E(wz,y)$ para toda aresta $uv,wz\in E$ e $0<x,y<1$ números reais.
\end{enumerate}
Um grafo planar junto com uma imersão fixada é chamado de grafo \defi{plano}.

Dado um grafo plano~$G$ com imersão~$\phi$, se removermos a imagem de $\phi$ do plano obteremos regiões conexas chamadas de \defi{faces}~\cite{planarTheoryAlgorith}.
A fronteira de uma face~$f$ é a usa fronteira topológica e corresponde a um subgrafo de~$G$\TODO{Citar Diestel}.
Cada aresta está na fronteira de duas faces (não necessariamente distintas\TODO{Lema 4.2.1, Diestel}.
A Figura~\ref{fig:MSF-basico-0} mostra as faces de um grafo plano.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-0.tex}
}
\caption{Um grafo ponderado plano e suas faces.}
\label{fig:MSF-basico-0}
\end{figure}

\begin{theorem}[Fórmula de Euler]
\label{teo:MSFEuler}
Seja $G=(V,E)$ um grafo planar conexo com~$n$ vértices e~$m$ arestas. Toda imersão de~$G$ no plano possui o mesmo número $f$ de faces e
$$
n-m+f = 2.
$$
\end{theorem}

Para cada vértice $v$ de um grafo plano, é possível construir uma ordenação cíclica~$D(v)$ das aresta incidentes a~$v$~\cite{noma2003}.
Para obter essa ordenação, percorremos as arestas incidentes a~$v$ em sentido horário até retornar à aresta inicial do percurso.
Uma aresta $vu$ é \defi{sucessora} de uma aresta $vw$ se a primeira é sucessora da segunda nesse percurso.
Uma lista de todas essas ordens cíclicas é chamada de~\defi{descrição combinatória plana} da imersão.
A Tabela \TODO{bla} mostra as ordenações de cada vértice do grafo da Figura \TODO{bla}.

A \defi{descrição combinatória} de um grafo plano é essencialmente uma lista de adjacências em que a ordem das células é relevante.
Como estamos admitindo arestas paralelas, o número de ocorrêcias de um vértice~$u$ na lista de um vértice~$v$ será exatamente o número de arestas paralelas entre~$u$ e~$v$.
Um laço num vértice~$u$ corresponderá a duas ocorrências de~$u$ na sua lista de adjacências.

Para o algoritmo que vamos descrever nesse capítulo, cada aresta possui um identificador.
Observe que cada aresta corresponde a duas células nas listas de adjacência do grafo:
Se os extremos de uma aresta são~$u$ e~$v$, há uma célula com~$u$ na lista de~$v$ e uma célula com~$v$ na lista de~$u$, ambos representando essa aresta.

Pensamos nessas células como representações das duas possíveis orientações da aresta: de~$u$ para~$v$ (algumas vezes denotada por~$uv$) e de~$v$ para~$u$ (algumas vezes denotada por $vu$).
Essas duas células armazenarão o identificador da aresta e terão um apontador $\varname{sym}$, referenciando a outra e vice-versa.
Ademais, cada uma dessas células possuirá também um campo $\varname{orig}$, que identificará o vértice a cuja lista pertence, ou seja, o vértice que é a origem da aresta orientada representada pela célula.

É possível obter uma descrição combinatória plana em tempo linear~\TODO{Citar fonte}.

\section{Dualidade}
\label{sec:dualidade}


Dado um grafo plano, o grafo \defi{dual} de~$G$~\cite{planarTheoryAlgorith} é o grafo $G^\star = (F,E^\star)$ cujo conjunto de vértices é o conjunto~$F$ de faces de~$G$ e o conjunto de arestas $E^\star$ é construido a partir das arestas de~$G$.
Para cada aresta~$e\in E$, existe exatamente uma aresta~$e^\star$ no conjunto $E^\star$.
A aresta~$e^\star$ é chamada de \defi{aresta dual} de~$e$ e os vértices incidentes a essa aresta são as duas faces (não necessariamente distintas) cujas fronteiras contém~$e$.
Nesse contexto, chamamos~$G$ de grafo \defi{primal}.
Para ilustrar a relação entre cada aresta e seu dual, geralmente desenhamos cada aresta do grafo dual cruzando a correspondente aresta do grafo primal, como mostra a Figura~\ref{fig:MSF-basico-1}.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-1.tex}
}
\caption{Um grafo ponderado plano e seu dual.}
\label{fig:MSF-basico-1}
\end{figure}


Se~$G$ tem $n$ vértices e~$m$ arestas, o Teorema~\ref{teo:MSFEuler} mostra que o número de vértices do grafo dual é $\OTheta{n+m}$.

\begin{theorem}[\cite{EPPSTEIN-planar}]
\label{teo:MSFdual}
Seja~$T$ uma árvore geradora de um grafo plano conexo~$G$. O conjunto
$$
T^\star = \{e^\star:e\notin T\}
$$
é uma árvore geradora de~$G^\star$.
Além disso, se~$G$ for ponderado e adotarmos $w(e^\star) = w(e)$, então~$T$ será de peso mínimo se e somente se~$T^\star$ for de peso máximo e vice versa.
\end{theorem}

A Figura~\ref{fig:MSF-figura-2} mostra~$T$ e~$T^\star$ do grafo da Figura~\ref{fig:MSF-basico-1}.


\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-2}
}
\caption{A árvore geradora de peso mínimo do grafo da Figura~\ref{fig:MSF-basico-1} e seu dual.}
\label{fig:MSF-figura-2}
\end{figure}



Dado um grafo~$G$, um \defi{corte} é um conjunto de arestas cuja remoção aumenta o conjunto de componentes conexas de~$G$.
Dado $F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$, então existe um corte associado ao par $(F, uv)$ dado pela união de $uv$ com as arestas que reconectam as duas árvores geradas pela remoção de $uv$.


\begin{theorem}
\label{teo:cutset}
Seja~$G$ um grafo planar, $F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$, então o conjunto
$$
(F, uv)^\star := \{e^\star:e\in (F, uv)\}
$$
forma um ciclo em $G^\star$.
\end{theorem}


\section{Definição do problema}
\label{sec:definition-MSF}

Ele consiste na busca por uma implementação tão eficiente quanto possível para a seguinte biblioteca:

\begin{itemize}
\item \MSFCreate($n$): Cria e devolve um grafo plano ponderado~$G$ com $n$ vértices isolados.
\item \MSFaddEdge($G$, $u$, $v$, $w$): Insere uma nova aresta com peso~$w$ ligando os vértices~$u$ e~$v$.
\item \MSFdelEdge($G$, $e$): Recebe um grafo plano ponderado~$G$ e uma aresta~$e$ de~$G$ e a remove do grafo.
\item \MSFupdate($G$, $u$, $v$, $w$): atribui o peso~$w$ à aresta~$uv$ do grafo dinâmico~$G$.
\item \MSFweight($G$): devolve o peso de uma MSF de $G$.
\end{itemize}


\begin{comment}
\section{Link-Cut Trees}
\label{sec:linkcuttree}

Para uma introdução sobre link-cut trees, recomendamos o trabalho de~\cite{linkcuttree}.

\begin{itemize}
\item \linkcutCreate(): Cria e retorna um novo nó de link-cut tree.
\item \linkcutAddEdge($v$, $w$): Adiciona uma aresta de~$v$ a~$w$, tornando~$v$ um filho de~$w$. Essa operação assume que~$v$ é a raiz de uma árvore~$T$ e que $w$ não é um nó de~$T$.
\item \linkcutDelEdge($v$): Remove a aresta de~$v$ para seu pai.
\item \linkcutEvert($v$): Torna~$v$ a raiz de sua árvore revertendo o caminho de~$v$ para a raiz original.
\item \linkcutMax($v$): Retorna o nó de peso máximo no caminho entre~$v$ e a raiz de sua árvore.
\item \linkcutMin($v$): Retorna o nó de peso mínimo no caminho entre~$v$ e a raiz de sua árvore.
\end{itemize}
\end{comment}

\section{Representação de um grafo dinâmico ponderado}
Nessa seção detalharemos como um grafo dinâmico ponderado conexo~$G$ é representado usando Link-Cut Trees com ordenação nas arestas.



Para representar~$G$, serão mantidas versões modificadas de uma árvore geradora de pesos mínimos~$T$ e sua floresta dual~$T^\star$ como definida no Teorema~\ref{teo:MSFdual} usando Link-Cut Trees com ordenação nas arestas.

\begin{figure}[htb]
%\scalebox{2}{
\centering
\input{fig/MSF-basico-3}
%}
\caption{As árvores geradoras modificadas que representam o grafo da Figura~\ref{fig:MSF-basico-1}.}
\label{fig:MSF-figura-3}
\end{figure}



\section{Link-Cut Trees com ordem nas arestas}


\begin{itemize}
\item \LCOMakeNode(): Retorna o identificador único de um novo nó~$v$.
\item \LCOMerge($u$, $v$): Recebe dois nós $u$ e $v$ de mesmo peso e retorna um único nó~$w$ que é a união desses nós.
Se~$\alpha$ e~$\beta$ são respectivamente as listas ordenadas de arestas incidentes a~$u$ e a~$v$ seguindo a descrição combinatória plana, então $\alpha\beta$ é a lista de arestas incidentes a~$w$.
\item \LCOSplit($v$, $e$): Recebe um nó~$v$ e uma aresta~$e$ incidente a~$v$.
Corta o nó~$v$ em dois nós~$v'$ e~$v''$. Se $\alpha e\beta$ é a lista ordenada de arestas incidentes a~$v$, então $\alpha e$ e~$\beta$ são as listas ordenadas de arestas incidentes a~$v'$ e~$v''$, respectivamente.
\item \LCOLink($v$, $w$): Adiciona uma aresta de~$v$ a~$w$, tornando~$v$ um filho de~$w$. Essa operação assume que~$v$ é a raiz de uma árvore~$T$ e que $w$ não é um nó de~$T$.
\item \LCOCycle
\item \LCOLoop($v$): Recebe um identificador único de um nó e adiciona um laço a ele.
\item \LCOAddCost($v$, $w$): Recebe o identificador único de um nó e um novo peso~$w$ e atribui o peso~$w$ ao nó~$v$.
\end{itemize}

Manteremos duas tabelas hash:

\hashNP($v$): Recebe um vértice~$v$ e torna ponteiros para nós~$v_{first}$ e~$v_{last}$.

\hashEdges:\TODO{????}

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-4}
}
\caption{As árvores geradoras modificadas que representam o grafo da Figura~\ref{fig:MSF-basico-1}.}
\label{fig:MSF-figura-4}
\end{figure}


\section{Tratando mudança de peso de arestas}

Descreveremos~\MSFupdate{}.

Construiremos~$T$ e~$T^\star$ na rotina \MSFCreate($G_0$), cuja implementação está detalhada no Algoritmo~\ref{Algo:MSFCreate}.
Nessa rotina, primeiro usaremos a rotina auxiliar~\order{} para ordenar as arestas de~$G_0$ em ordem crescente de peso e retornar uma lista com essas arestas ordenadas.
Lembramos que~$G_0$ mantém, para cada aresta~$uv$, sua aresta dual~$uv^\star$, dessa forma, para não perder essa informação, faremos com que cada entrada da lista retornada por~\order{}
possua ponteiros para~$uv$, seu peso~$w$ e~$uv^\star$.


\TODO{Figura de $T$ e $T^\star$ como Link-Cut Trees com nós representando vértices e arestas}

Em seguida percorreremos essa lista sequencialmente e para cada aresta~$uv$ nela, faremos um teste de conexidade entre os vértices~$u$ e~$v$.
Se~$u$ e~$v$ não estiverem conectados, então inserimos~$uv$ em~$F$ com peso~$w$, caso contrário inserimos $uv^\star$ em~$F^\star$ com o mesmo peso~$w$.

Como inserimos as arestas em ordem crescente de peso, a floresta~$F$ é de pesos mínimos e logo, pelo Teorema~\ref{teo:MSFdual}, $F^\star$ é de pesos máximos.

\begin{algorithm}[htb]
\caption{\MSFCreate($n$, $G_0$)}
\label{Algo:MSFCreate}
\begin{algorithmic}[1]
\State \varname{lista} $\gets$ \order($G_0$)
\For{$uv$ em \varname{lista}}\label{Algo:MSFCreate:linhafor}
\If \linkcutQuery($F$, $u$, $v$)\label{Algo:MSFCreate:query}
\State \linkcutAddEdge($G$.$F^\star$, $e$, $f$, $w$)\label{Algo:MSFCreate:link1}
\Else
\State \linkcutAddEdge($G$.$F$, $u$, $v$, $w$)\label{Algo:MSFCreate:link2}
\EndIf
\EndFor
\State \Return $G$
\end{algorithmic}
\end{algorithm}

Existem diversos algoritmos conhecidos na literatura que podem implementar a rotina \order{}~\cite{CLRS} com consumo de tempo~$\O{m\lg m}$, onde $m$ é o tamanho da lista,
que, no nosso caso, coincide com o número de arestas do grafo~$G_0$.
O laço da linha~\ref{Algo:MSFCreate:linhafor} do Algoritmo~\ref{Algo:MSFCreate} itera~$m$ vezes e cada teste de conexidade da linha~\ref{Algo:MSFCreate:query} e cada chamada para a rotina  \linkcutAddEdge{} nas linhas~\ref{Algo:MSFCreate:link1} e~\ref{Algo:MSFCreate:link2} possuem consumo de tempo~$\O{\lg n}$, onde~$n$ é o número de vértices do grafo.
Logo o consumo de tempo de \MSFCreate{} é $\O{m\lg n}$.

Para implementar \MSFweight{} faremos com que cada nó das link-cut trees tenha um campo~$w$ que contabiliza o peso total da subárvore enraizada naquele nó.
Dessa forma, para obter o peso da floresta maximal de peso mínimo~$F$ que estamos mantendo, basta retornar o campo $w$ da raiz de~$F$.
Essa rotina consome tempo constante.

\begin{algorithm}[htb]
\caption{\MSFweight($G$)}
\label{Algo:MSFweight}
\begin{algorithmic}[1]
\State \Return $G$.$F$.$w$
\end{algorithmic}
\end{algorithm}

Quando atualizamos o peso de uma aresta~$uv$ com a rotina \MSFupdate{} para um novo peso~$w$, cuja implementação pode ser vista no Algoritmo~\ref{Algo:MSFupdate}, precisamos garantir que a floresta~$F$ resultante continuará sendo  de peso mínimo.

Notemos que ou $uv\in F$ ou $uv^\star\in F^\star$, iremos tratar cada um desses casos separadamente.
A identificação de qual caso~$uv$ se encontra é feita na linha~\ref{Algo:MSFupdate:linhauvinF} do Algoritmo~\ref{Algo:MSFupdate}, para implementar essa consulta, não podemos fazer como foi feito linha~\ref{Algo:dymGraphReplace:linhayinTv} do \dymGraphReplace(Algoritmo~\ref{Algo:dymGraphReplace}), pois link-cut trees não possuem nós que representam arestas.
Portanto precisamos recorrer a recursos mais elaborados.
Manteremos um dicionário que guardará apontadores para os nós de~$F$ e usaremos como o conjunto de chaves os vértices de $G$. O apontador associado à chave~$u$ aponta para o nó que representa o vértice $u$.
Após usar esse dicionário para obter os nós que representam os vértices~$u$ e~$v$ usamos a rotina \linkcutPath{} para fazer o caminho entre~$u$ e~$v$ ser preferido e verificamos se~$u$ é predecessor ou sucessor de~$v$.

Se~$uv$ for uma aresta de~$F$ e se existir alguma aresta no corte~$(F, uv)$ com peso menor do que~$w$, então~$F$ não será mais de peso mínimo.
Para corrigir isso, precisamos tomar~$xy$ como a aresta de menor peso no corte~$(F, uv)$,
então remover~$uv$ de~$F$ e adicionar~$xy$ a~$F$.
Dessa forma, garantindo que~$F$ seja de peso mínimo.

Para obter a aresta~$xy$, vamos investigar o corte~$(F, uv)$.
Pelo Teorema~\ref{teo:cutset}, o conjunto~$(F, uv)^\star$ forma um ciclo em~$G^\star$.
Como~$uv^\star\in(F, uv)$ e~$uv$ é a única aresta de~$F$ cujo dual está em~$(F, uv)$, então as demais arestas desse corte formam um caminho em~$F^\star$ ligando os vértices incidentes a~$uv^\star$.
Utilizando a rotina \linkcutMin{}  da biblioteca de link-cut trees podemos obter o nó de menor peso nesse percurso.

Note também que, se modificarmos~$F$, então precisaremos atualizar~$F^\star$, removendo $xy^\star$ de~$F^\star$ e adicionando $uv^\star$ com o novo peso~$w$.

Se~$uv$ não for uma aresta de~$F$, então teremos que~$uv^\star$ é uma aresta de~$F^\star$.
O tratamento desse caso é análogo ao caso anterior e é feito entre as linhas~\ref{Algo:MSFupdate:dualinicio} e~\ref{Algo:MSFupdate:dualfim} do Algoritmo~\ref{Algo:MSFupdate}.

Como cada rotina de link-cut trees utilizada consome tempo~$\O{\lg n}$ amortizado, então o consumo de tempo de \MSFupdate{} também é~$\O{\lg n}$ amortizado.



\MSFupdate($H$, $e$, $w$) recebe a hash $H$, uma aresta~$e$ e um peso~$w$ e atualiza o peso de $e$ para ser~$w$ e atualiza $T$ e~$T^\star$.

\begin{algorithm}[htb]
\caption{\MSFupdate($H$, $e$, $w$)}
\label{Algo:MSFupdate}
\begin{algorithmic}[1]
\State $\hat e$, $e_0$, $e_1$, $e_2$, $e_3$ $\gets$ $H$($e$)
\State $\hat e.w$ $\gets$ $w$
\If {$e$ $\in$ $T$}\label{Algo:MSFupdate:linhauvinF}

\State \linkcutEvert($e_1$)
\State $\hat d$ $\gets$ \linkcutMin($e_3$)

\If {$\hat d$.$w$ $=$ $\infty$}
\Comment {A aresta $e^\star$ é um laço.}
\State \Return
\EndIf
\State $d$ $\gets$ $\hat d.\varname{id}$
\State $\hat d$, $d_0$, $d_1$, $d_2$, $d_3$ $\gets$ $H$($d$)
\If {$\hat d$.$w$ > $w$}
\State \linkcutEvert($e_0$); \linkcutDelEdge($\hat e$); \linkcutDelEdge($e_2$)

\State \linkcutEvert($d_1$); \linkcutDelEdge($\hat d$); \linkcutDelEdge($d_3$)

\State \linkcutEvert($e_3$); \linkcutAddEdge($e_3$, $\hat e$); \linkcutAddEdge($\hat e$, $e_1$)

\State \linkcutEvert($d_0$); \linkcutAddEdge($d_0$, $\hat d$); \linkcutAddEdge($\hat d$, $d_2$)
\EndIf

\Else

\State \linkcutEvert($e_0$)
\State $\hat d$ $\gets$ \linkcutMax($e_2$)

\If {$\hat d$.$w$ $=$ $-\infty$}
\State \Return
\EndIf
\State $d$ $\gets$ $\hat d.\varname{id}$
\State $\hat d$, $d_0$, $d_1$, $d_2$, $d_3$ $\gets$ $H$($d$)
\If {$\hat d$.$w$ < $w$}

\State \linkcutEvert($d_0$); \linkcutDelEdge($\hat d$); \linkcutDelEdge($d_2$)
\State \linkcutEvert($e_1$); \linkcutDelEdge($\hat e$); \linkcutDelEdge($e_3$)

\State \linkcutEvert($e_0$); \linkcutAddEdge($e_0$, $\hat e$); \linkcutAddEdge($\hat e$, $e_2$)

\State \linkcutEvert($d_1$); \linkcutAddEdge($d_1$, $\hat d$); \linkcutAddEdge($\hat d$, $d_3$)

\EndIf
\EndIf
\end{algorithmic}
\end{algorithm}

\section{Implementação de \LCOSplice{} e \LCOMakeEdge{} com Link-Cut trees com ordem nas arestas}
\LCOMakeEdge(): Cria e retorna duas link cut trees tradicionais. A primeira representa uma aresta e a segunda o seu dual, como ilustrado na Figura~\TODO{bla}. Cada uma possui~$4$ nós.A aresta representada possui peso~$\infty$.


\LCOSplice{}


\begin{algorithm}[htb]
\caption{\LCOMakeEdge()}
\label{Algo:LCOMakeEdge}
\begin{algorithmic}[1]
\State $u$ $\gets$ \LCOMakeNode()
\State $v$ $\gets$ \LCOMakeNode()
\State $f$ $\gets$ \LCOMakeNode()
\State \LCOLink($u$, $v$)
\State \LCOLoop($f$)
\end{algorithmic}
\end{algorithm}

\section{Resolvendo MSF dinâmico com \LCOSplice{} e \LCOMakeEdge{}}




\begin{algorithm}[htb]
\caption{\MSFaddEdge($e$, $d$, $w$)}
\label{Algo:MSFaddEdge}
\begin{algorithmic}[1]
\State $f$ $\gets$ \LCOMakeEdge()
\State \LCOSplice($e$,$f$)
\State \LCOSplice($d$,$f$)
\State \MSFupdate($f$, $w$)
\State \Return $e$.$id$ 
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[htb]
\caption{\MSFdelEdge($e$, $d$)}
\label{Algo:MSFdelEdge}
\begin{algorithmic}[1]
\State $f$ $\gets$ \LCOMakeEdge()
\State \LCOSplice($e$,$e$)
\State \LCOSplice($d$,$d$)
\State \Return $e$.$id$ 
\end{algorithmic}
\end{algorithm}
