\chapter{Floresta maximal de peso mínimo em grafos planos}
\label{sec:MSF}

O problema da floresta maximal de peso mínimo em grafos planos dinâmicos foi inicialmente apresentado na Seção~\ref{sec:Motivação} e é o segundo problema que iremos discutir.
O objetivo desse capítulo é apresentar o algoritmo de David Eppstein, Giuseppe Italiano, Roberto Tamassia, Robert Tarjan, Jeffery Westbrook e Moti Yung~\cite{EPPSTEIN-planar} que resolve esse problema para grafos planos que podem ter laços e arestas paralelas.

O estudo desse problema se inicia com uma revisão de conceitos de planaridade e dualidade apresentados nas Seções~\ref{sec:planaridade} e~\ref{sec:dualidade} respectivamente.
Esses conceitos são bem estabelecidos na literatura e essas seções são baseadas na Seção~4.2 do livro \textit{Graph Theory} de Reinhard Diestel~\cite{Diestel}.

Os conceitos apresentando nessas duas seções iniciais serão usados para definir formalmente o problema, o que é feito na Seção~\ref{sec:definition-MSF}, e para fundamentar a estrutura de dados que resolve esse problema, que será apresentada na Seção~\ref{sec:EODT}.

\section{Planaridade}
\label{sec:planaridade}

Intuitivamente, um grafo é dito plano se ele está desenhado em uma folha de papel de forma que suas arestas não se cruzem.
Formalmente, um \defi[grafo!plano]{grafo plano}~\cite{Diestel} é um par de conjuntos finitos $G = (V, E)$ com as seguintes propriedades:
\begin{enumerate}
\item $V\subset \R^2$;
\item Toda aresta é um arco entre dois vértices;
\item O interior de uma aresta não contém vértices nem intersecta outras arestas.
\end{enumerate}
Quando conveniente, $G$ será usado tanto para o par~$(V ,E)$ quanto para o conjunto~${V\cup\bigcup E}$.

Para cada grafo plano~$G$, ao remover~$G$ do plano~$\R^2$, é obtido um conjunto finito~$F(G)$ de regiões conexas que é chamado de \defi{conjunto de faces} de~$G$.
Naturalmente, cada uma dessas regiões é chamada de uma \defi{face} de $G$.
A Figura~\ref{fig:MSF-basico-0} mostra um grafo plano~$G$ e suas as faces.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-0.tex}
}
\caption{Um grafo ponderado plano e suas faces.}
\label{fig:MSF-basico-0}
\end{figure}



\begin{lemma}[Lemma 4.2.2~\cite{Diestel}]
Seja $G$ um grafo plano e $e$ uma de suas arestas.
\begin{enumerate}
\item Se $X$ é a fronteira de uma face de~$G$, então ou $e\subseteq X$ ou a intersecção de $X$ com o interior de $e$ é vazia.
\item Se $e$ pertence a um ciclo de $G$, então $e$ pertence à fronteira de exatamente duas faces distintas de $G$;
\item Se não existe ciclo que contém $e$, então $e$ pertence à fronteira de uma única face de~$G$.
\end{enumerate}
\end{lemma}

\begin{theorem}[Fórmula de Euler, Teorema 4.2.9~\cite{Diestel}]
\label{teo:MSFEuler}
Seja $G=(V,E)$ um grafo planar conexo com~$n$ vértices e~$m$ arestas. Toda imersão de~$G$ no plano possui o mesmo número $f$ de faces e
$$
n-m+f = 2.
$$
\end{theorem}

Para cada vértice $v$ de um grafo plano, é possível construir uma ordenação cíclica~$D(v)$ das aresta incidentes a~$v$~\cite{noma2003}.
Para obter essa ordenação, percorremos as arestas incidentes a~$v$ em sentido anti-horário até retornar à aresta inicial do percurso.
Uma aresta é dita \defi{sucessora} de outra aresta se a primeira é sucessora da segunda nesse percurso.
Uma lista de todas essas ordens cíclicas é chamada de~\defi{descrição combinatória plana} da imersão.
Abaixo temos uma descrição combinatória plana do grafo da Figura~\ref{fig:MSF-basico-0}.
\begin{align*}
D(u)&=\langle (a,u), (b,u), (c,u))\rangle\\
D(v)&=\langle (a,v), (e,v), (b,v)  \rangle\\
D(z)&=\langle (e,z), (d,z), (d,z), (c,z)\rangle
\end{align*}

A descrição combinatória de um grafo plano é essencialmente uma lista de adjacências em que a ordem das células é relevante.
Como estamos admitindo arestas paralelas, o número de ocorrências de um vértice~$u$ na lista de um vértice~$v$ será exatamente o número de arestas paralelas entre~$u$ e~$v$.
Um laço num vértice~$u$ corresponderá a duas ocorrências de~$u$ na sua lista de adjacências.

Para o algoritmo que vamos descrever nesse capítulo, cada aresta possui um identificador.
Observe que cada aresta corresponde a duas células nas listas de adjacência do grafo:
Se os extremos de uma aresta são~$u$ e~$v$, há uma célula com~$u$ na lista de~$v$ e uma célula com~$v$ na lista de~$u$, ambos representando essa aresta.

Pensamos nessas células como representações das duas possíveis orientações da aresta: de~$u$ para~$v$ (algumas vezes denotada por~$uv$) e de~$v$ para~$u$ (algumas vezes denotada por $vu$).
Essas duas células armazenarão o identificador da aresta e terão um apontador $\varname{sym}$, referenciando a outra e vice-versa.
Ademais, cada uma dessas células possuirá também um campo $\varname{orig}$, que identificará o vértice a cuja lista pertence, ou seja, o vértice que é a origem da aresta orientada representada pela célula.

\section{Dualidade}
\label{sec:dualidade}


Dado um grafo plano, o grafo \defi{dual} de~$G$~\cite{Diestel} é o grafo $G^\star = (F,E^\star)$ cujo conjunto de vértices é o conjunto~$F = F(G)$ de faces de~$G$ e o conjunto de arestas $E^\star$ é construído a partir das arestas de~$G$.
Para cada aresta~$e\in E$, existe exatamente uma aresta~$e^\star$ no conjunto $E^\star$.
A aresta~$e^\star$ é chamada de \defi[aresta!dual]{aresta dual} de~$e$ e os vértices incidentes a essa aresta são as duas faces (não necessariamente distintas) cujas fronteiras contém~$e$.
Nesse contexto, chamamos~$G$ de grafo \defi{primal}.
Para ilustrar a relação entre cada aresta e seu dual, geralmente desenhamos cada aresta do grafo dual cruzando a correspondente aresta do grafo primal, como mostra a Figura~\ref{fig:MSF-basico-1}.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-1.tex}
}
\caption{Um grafo ponderado plano e seu dual.}
\label{fig:MSF-basico-1}
\end{figure}


Se~$G$ tem $n$ vértices e~$m$ arestas, o Teorema~\ref{teo:MSFEuler} mostra que o número de vértices do grafo dual é $\OTheta{n+m}$.

\begin{theorem}[\cite{EPPSTEIN-planar}]
\label{teo:MSFdual}
Seja~$T$ uma árvore geradora de um grafo plano conexo~$G$. O conjunto
$$
T^\star = \{e^\star:e\notin T\}
$$
é uma árvore geradora de~$G^\star$.
Além disso, se~$G$ for ponderado e adotarmos $w(e^\star) = w(e)$, então~$T$ será de peso mínimo se e somente se~$T^\star$ for de peso máximo e vice versa.
\end{theorem}

A Figura~\ref{fig:MSF-figura-2} mostra~$T$ e~$T^\star$ do grafo da Figura~\ref{fig:MSF-basico-1}.

\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-2}
}
\caption{Árvore geradora~$T$ de peso mínimo do grafo da Figura~\ref{fig:MSF-basico-1} e árvore correspondente~$T^\star$ do grafo.}
\label{fig:MSF-figura-2}
\end{figure}



Dado um grafo~$G$, um \defi{corte} é um conjunto de arestas cuja remoção aumenta o conjunto de componentes conexas de~$G$.
Dado $F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$, então existe um corte associado ao par $(F, uv)$ dado pela união de $uv$ com as arestas que reconectam as duas árvores geradas pela remoção de $uv$.


\begin{theorem}
\label{teo:cutset}
Seja~$G$ um grafo planar, $F$ uma floresta maximal de~$G$ e~$uv$ uma aresta de~$F$, então o conjunto
$$
(F, uv)^\star := \{e^\star:e\in (F, uv)\}
$$
forma um ciclo em $G^\star$.
\end{theorem}


\section{Definição do problema}
\label{sec:definition-MSF}
O problema da floresta maximal de peso mínimo (MSF) em grafos dinâmicos planos ponderados consiste na busca por uma implementação tão eficiente quanto possível para a seguinte biblioteca:

\begin{itemize}
\item \MSFCreate($n$): Cria e devolve um grafo plano ponderado~$G$ com $n$ vértices isolados.
\item \MSFaddEdge($G$, $e$, $u$, $e_u$, $v$, $e_v$, $w$): Insere em~$G$ uma nova aresta~$e$ com peso~$w$ ligando os vértices~$u$ e~$v$. A nova aresta~$e$ é sucessora das arestas~$e_u$ e~$e_v$ nas ordenações cíclicas de~$u$ e~$v$, respectivamente.
\item \MSFdelEdge($G$, $e$): Remove a aresta~$e$ de~$G$.
\item \MSFupdate($G$, $e$, $w$): Altera o peso da aresta~$e$ do grafo dinâmico~$G$ para o valor~$w$.
\item \MSFweight($G$): Devolve o peso de uma MSF de $G$.
\end{itemize}


\section{Árvores dinâmicas planas}
\label{sec:EODT}

Para resolver o problema da floresta geradora de peso mínimo em grafos dinâmico planos ponderados, Eppstein et al.~\cite{EPPSTEIN-planar} propõem o uso de uma estrutura de dados que chamaremos de \defi[arvore@\'arvore!dinâmica plana]{Árvores dinâmicas planas} (ADP).

Seguindo a descrição de Eppstein et al.~\cite[Seção 3]{EPPSTEIN-planar}, essa estrutura consiste de árvores em que cada nó possui um peso, juntamente com uma descrição combinatória plana das árvores.
Como árvores não possuem arestas paralelas, consideraremos que a ordenação cíclica para cada nó~$u$ é uma sequência dos nós vizinhos de~$u$ no ordem anti-horária em vez de arestas.

Árvores dinâmicas planas dão suporte à seguinte biblioteca:
\begin{itemize}
\item \LCOMakeNode(): Cria e retorna um novo nó.
\item \LCOLink($v$, $w$): Adiciona uma aresta ligando os nós~$v$ a~$w$, tornando~$v$ um filho de~$w$.
O nó $w$ é inserido no final de~$D(v)$ e~$v$ no inicio de~$D(w)$.
Essa operação assume que~$v$ é a raiz de sua árvore e que $v$ e $w$ estão em árvores distintas.
\item \LCOMerge($u$, $v$): Recebe dois nós~$u$ e~$v$ de mesmo peso e retorna um único nó~$z$ que é a união desses nós.
Se~$\alpha$ e~$\beta$ são respectivamente as ordenações cíclicas de arestas incidentes a~$u$ e a~$v$ seguindo a descrição combinatória plana, então $\alpha\beta$ é a lista de arestas incidentes a~$z$.
\item \LCOSplit($u$, $e$): Recebe nós adjacentes~$u$ e~$e$.
Substitui o nó~$u$ por dois nós~$v$ e~$z$.
Se a ordem cíclica $D(u)$ tem forma $\alpha e\beta$, então $\alpha e$ e~$\beta$ são as ordens cíclicas de~$v$ e~$w$, respectivamente.
\item \LCOCycle($v$, $e$): Permuta ciclicamente $D(v)$ de forma que o nó $e$ é o último na ordem. Se a ordem inicial tem forma $\alpha e \beta$, então a ordem resultante é $\beta\alpha e$.
\item \LCORoot($v$): Retorna a raiz da árvore do nó~$v$.
\item \LCOAddCost($v$, $w$): Atribui o peso~$w$ ao nó~$v$.
\item \LCOMax($u$, $v$): Retorna o nó de peso máximo no percurso entre os nós~$u$ e~$v$.
\item \LCOMin($u$, $v$): Retorna o nó de peso mínimo no percurso entre os nós~$u$ e~$v$.
\item \LCOPredecessor($u$, $e$): Retorna o predecessor do nó~$e$ na ordem cíclica de $u$.
\end{itemize}

A estrutura também se aplica a grafos planos desconexos, funcionando como a união independente das estruturas correspondentes para cada componente do grafo.

\section{Resolvendo MSF com árvores dinâmicas planas}

A ideia é basicamente usar Link-Cut trees para armazenar~$T$ e~$T^\star$.
Para manter a associação que há entre as arestas de~$G$ e~$G^\star$, as link cut Trees conterão também nós para representar as arestas de~$G$ e~$G^\star$.

Especificamente, cada aresta~$e$ de~$G$ corresponderá a quatro nós nas link-cut trees: dois da link-cut trees da link-cut tree de~$T$ e dois da link-cut tree de~$T^\star$.
Esses nós são chamados de $e_0$, $e_1$, $e_2$ e $e_3$, sendo $e_0$ e $e_2$ os nós da link cut tree de~$T$ e~$e_1$ e~$e_3$ da link-cut tree de~$T^\star$.
Se $e\in T$, então $e_0$ e $e_2$ estão conectados, senão $e_1$ e $e_3$ estão conectados na respectiva link-cut tree.

Além das árvores, as link-cut trees vão armazenar também informação sobre a imersão de~$G$.
Isso será feito da seguinte maneira.

\TODO{Completar com node path e ordem ciclica de $e_i$}


\begin{figure}[htb]
%\scalebox{2}{
\centering
\input{fig/MSF-basico-3}
%}
\caption{As árvores geradoras modificadas que representam o grafo da Figura~\ref{fig:MSF-basico-1}.}
\label{fig:MSF-figura-3}
\end{figure}


Quando atualizamos o peso de uma aresta~$uv$ com a rotina \MSFupdate{} para um novo peso~$w$, cuja implementação pode ser vista no Algoritmo~\ref{Algo:MSFupdate}, precisamos garantir que a floresta~$F$ resultante continuará sendo  de peso mínimo.

Notemos que ou $uv\in F$ ou $uv^\star\in F^\star$, iremos tratar cada um desses casos separadamente.
A identificação de qual caso~$uv$ se encontra é feita na linha~\ref{Algo:MSFupdate:linhauvinF} do Algoritmo~\ref{Algo:MSFupdate}, para implementar essa consulta, não podemos fazer como foi feito linha~\ref{Algo:dymGraphReplace:linhayinTv} do \dymGraphReplace(Algoritmo~\ref{Algo:dymGraphReplace}), pois link-cut trees não possuem nós que representam arestas.
Portanto precisamos recorrer a recursos mais elaborados.
Manteremos um dicionário que guardará apontadores para os nós de~$F$ e usaremos como o conjunto de chaves os vértices de $G$. O apontador associado à chave~$u$ aponta para o nó que representa o vértice $u$.
Após usar esse dicionário para obter os nós que representam os vértices~$u$ e~$v$ usamos a rotina \linkcutPath{} para fazer o caminho entre~$u$ e~$v$ ser preferido e verificamos se~$u$ é predecessor ou sucessor de~$v$.

Se~$uv$ for uma aresta de~$F$ e se existir alguma aresta no corte~$(F, uv)$ com peso menor do que~$w$, então~$F$ não será mais de peso mínimo.
Para corrigir isso, precisamos tomar~$xy$ como a aresta de menor peso no corte~$(F, uv)$,
então remover~$uv$ de~$F$ e adicionar~$xy$ a~$F$.
Dessa forma, garantindo que~$F$ seja de peso mínimo.

Para obter a aresta~$xy$, vamos investigar o corte~$(F, uv)$.
Pelo Teorema~\ref{teo:cutset}, o conjunto~$(F, uv)^\star$ forma um ciclo em~$G^\star$.
Como~$uv^\star\in(F, uv)$ e~$uv$ é a única aresta de~$F$ cujo dual está em~$(F, uv)$, então as demais arestas desse corte formam um caminho em~$F^\star$ ligando os vértices incidentes a~$uv^\star$.
Utilizando a rotina \linkcutMin{}  da biblioteca de link-cut trees podemos obter o nó de menor peso nesse percurso.

Note também que, se modificarmos~$F$, então precisaremos atualizar~$F^\star$, removendo $xy^\star$ de~$F^\star$ e adicionando $uv^\star$ com o novo peso~$w$.

Se~$uv$ não for uma aresta de~$F$, então teremos que~$uv^\star$ é uma aresta de~$F^\star$.
O tratamento desse caso é análogo ao caso anterior e é feito entre as linhas~\ref{Algo:MSFupdate:dualinicio} e~\ref{Algo:MSFupdate:dualfim} do Algoritmo~\ref{Algo:MSFupdate}.

\begin{algorithm}[htb]
\caption{\MSFupdate($G$, $e$, $w$)}
\label{Algo:MSFupdate}
\begin{algorithmic}[1]
\State primal, $\hat e$, $\hat e_1$, $\hat e_3$ $\gets$ $H$($e$)
\State \LCOAddCost($\hat e$, $w$); \LCOAddCost($\hat e_1$, $w$); \LCOAddCost($\hat e_2$, $w$)
\State \LCOEvert($\hat e_1$)
\If {primal}
\State $d$ $\gets$ \LCOMin($\hat e_3$)

\State primal, $\hat d$, $\hat d_0$, $\hat d_2$ $\gets$ $H$($d$)
\If {$\hat d_0$.$w$ < $w$}
\State $\hat d_1$, $\hat d_3$ $\gets$ \LCOSplit($\hat d$, \LCOParent($\hat d$))\Comment{Remove $d$ de $T^\star$}
\State $\hat e_0$, $\hat e_2$ $\gets$ \LCOSplit($\hat e$, \LCOParent($\hat e$))\Comment{Remove $e$ de $T$}


\State $\hat d$ $\gets$ \LCOMerge( $\hat d_0$, $\hat d_2$)

\State $\hat e$ $\gets$ \LCOMerge( $\hat e_1$, $\hat e_3$)
\State $H(e)$ $\gets$ falso, $\hat e$, $\hat e_0$, $\hat e_2$
\State $H(d)$ $\gets$ verdadeiro, $\hat d$, $\hat d_1$, $\hat d_3$

\EndIf

\Else
\State $d$ $\gets$ \LCOMax($\hat e_3$)

\State primal, $\hat d$, $\hat d_0$, $\hat d_2$ $\gets$ $H$($d$)
\If {$\hat d_0$.$w$ > $w$}
\State $\hat d_1$, $\hat d_3$ $\gets$ \LCOSplit($\hat d$, \LCOParent($\hat d$))\Comment{Remove $d$ de $T^\star$}
\State $\hat e_0$, $\hat e_2$ $\gets$ \LCOSplit($\hat e$, \LCOParent($\hat e$))\Comment{Remove $e$ de $T$}


\State $\hat d$ $\gets$ \LCOMerge( $\hat d_0$, $\hat d_2$)

\State $\hat e$ $\gets$ \LCOMerge( $\hat e_1$, $\hat e_3$)
\State $H(e)$ $\gets$ verdadeiro, $\hat e$, $\hat e_0$, $\hat e_2$
\State $H(d)$ $\gets$ falso, $\hat d$, $\hat d_1$, $\hat d_3$

\EndIf
\EndIf
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[htb]
\caption{\MSFaddEdge($v$, $e_v$, $u$, $e_u$)}
\label{Algo:MSFaddEdge}
\begin{algorithmic}[1]


\For {$i \in \{0,1,2,3\}$}
\State $\hat s_i$ $\gets$ \LCOMakeNode(); $\hat e_i$ $\gets$ \LCOMakeNode()
\State \LCOLink($\hat e_i$, $\hat s_i$)
\EndFor
\State \LCOCycle($\hat v$, $\hat e_v$)
\State \LCOMerge($\hat v$, $\hat s_v$)
\State \LCOCycle($\hat u$, $\hat e_u$)
\State \LCOMerge($\hat u$, $\hat s_u$)
\State
\State 




\State \MSFupdate($G$, $e$, $w$)
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[htb]
\caption{\MSFdelEdge($G$, $e$)}
\label{Algo:MSFdelEdge}
\begin{algorithmic}[1]
\State \MSFupdate($G$, $e$, $\infty$)
\State primal, $\hat e$, $\hat e_F$, $\hat e_G$ $\gets$ $H(e)$
\State $\hat v$ $\gets$ \LCOParent($\hat e_F$)
\State $\hat u$ $\gets$ \LCOParent($\hat e_G$)
\State \LCOCycle($\hat v$, $e_F$)
\State \LCOSplit(\LCOPredecessor($\hat u$, $\hat e_F$))
\State \LCOCycle($\hat v$, $e_G$)
\State \LCOSplit(\LCOPredecessor($\hat v$, $\hat e_G$))
\State
\State $\hat F_f$ $\gets$ \LCOLeftFace($\hat e_F$)
\State $\hat F_g$ $\gets$ \LCOLeftFace($\hat e_G$)
\State \LCOCycle($\hat F_f$, $\hat e$)
\State \LCOSplit(\LCOPredecessor($\hat F_f$, $\hat e$))
\State \LCOCycle($\hat F_g$, $\hat e$)
\State
\State \LCOMerge($\hat F_f$, $\hat F_g$)
\end{algorithmic}
\end{algorithm}

\section{Estruturas auxiliares}
\subsection{Árvores binárias de busca com chave implícita}
\subsection{Link-Cut Trees}
\label{sec:linkcuttree}

Para uma introdução sobre link-cut trees, recomendamos o trabalho de~\cite{linkcuttree}.

\begin{itemize}
\item \linkcutCreate(): Cria e retorna um novo nó de link-cut tree.
\item \linkcutAddEdge($v$, $w$): Adiciona uma aresta de~$v$ a~$w$, tornando~$v$ um filho de~$w$. Essa operação assume que~$v$ é a raiz de uma árvore~$T$ e que $w$ não é um nó de~$T$.
\item \linkcutDelEdge($v$): Remove a aresta de~$v$ para seu pai.
\item \linkcutEvert($v$): Torna~$v$ a raiz de sua árvore revertendo o caminho de~$v$ para a raiz original.
\item \linkcutMax($v$): Retorna o nó de peso máximo no caminho entre~$v$ e a raiz de sua árvore.
\item \linkcutMin($v$): Retorna o nó de peso mínimo no caminho entre~$v$ e a raiz de sua árvore.
\end{itemize}


\section{Implementação de árvores dinâmicas planas}

Além dessas rotinas, as árvores dinâmicas planas que implementaremos usaram duas rotinas internas.

\begin{itemize}
\item \LCOFindNode($s$): Recebe um sub-nó $s$ e retorna o nó que contêm $s$ em seu \textit{node path}.
\item \LCOFindSubNode($\hat v$, $\hat e$): Recebe dois nós e retorna o subnó $s$ e retorna o nó que contêm $s$ em seu \textit{node path}.
\end{itemize}





\begin{algorithm}[htb]
\caption{\LCOFindSubNode($\hat v$, $\hat e$)}
\label{Algo:LCOFindSubNode}
\begin{algorithmic}[1]
\If{ $e$ $\in$ $T$}
\State $v_{first}$, $v_{last}$ $\gets$ $\hat v$
\State $e_{first}$, $e_{last}$ $\gets$ $\hat e$
\State \linkcutEvert($v_{first}$)
\If{$e_{first}$.$parent$ $\neq$ $e_{last}$}
\State \Return $e_{first}$.$parent$
\EndIf
\State \Return $e_{last}$.$parent$
\Else
\If { \LCOFindNode($e_{first}.rot.parent$) $=$ $v$  }\Comment{$e_{first}$ e $e_{last}$ apontam pra $T^\star$}
\State \Return $e_{first}.rot.parent$
\Else
\State \Return $e_{last}.rot.parent$
\EndIf
\EndIf
\end{algorithmic}
\end{algorithm}



\begin{algorithm}[htb]
\caption{\LCOFindNode($s$)}
\label{Algo:LCOFindNode}
\begin{algorithmic}[1]
\State $r$ $\gets$ \treapGetRoot($s$)
\State \Return $r$.$\node$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[htb]
\caption{\LCOMerge($\hat u$, $\hat v$)}
\label{Algo:LCOMerge}
\begin{algorithmic}[1]
\State $\hat w$ $\gets$ \LCOMakeNode()
\State \linkcutEvert($\hat u$.$last$)
\State \linkcutAddEdge($\hat u$.$last$, $\hat v$.$first$)
\State $\hat w$.$first$  $\gets$ $\hat u$.$first$
\State $\hat w$.$last$  $\gets$ $\hat v$.$last$
\State $T$ $\gets$ \treapJoin(\treapGetRoot($\hat u$.$first$), \treapGetRoot($\hat v$.$last$))
\State $T$.$\node$ $\gets$ $\hat w$
\State \Return $\hat w$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[htb]
\caption{\LCOSplit($\hat u$, $\hat e$)}
\label{Algo:LCOSplit}
\begin{algorithmic}[1]
\State $s_e$ $\gets$ \LCOFindSubNode($\hat u$, $\hat e$)
\State $\hat v$ $\gets$ \LCOMakeNode()
\State $\hat w$ $\gets$ \LCOMakeNode()
\State \linkcutEvert($\hat u$.$last$)
\State $y$ $\gets$ \linkcutParent($s_e$)
\State \linkcutDelEdge($s_e$)
\State $T$, $u_{last}$, $T'$ $\gets$ \treapSplit($\hat u$.$last$)
\State $T$ $\gets$ \treapJoin($T$, $u_{last}$)
\State $T$.$\node$ $\hat w$
\State $T'$.$\node$ $\hat v$
\State $\hat v$.$first$ $\gets$ $\hat u$.$first$; $\hat v$.$last$ $\gets$ $s_e$
\State $\hat w$.$first$ $\gets$ $y$; $\hat w$.$last$ $\gets$ $u_{last}$
\State \Return $\hat v$, $\hat w$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[htb]
\caption{\LCOCycle($\hat v$, $\hat e$)}
\label{Algo:LCOCycle}
\begin{algorithmic}[1]
\State $s_e$ $\gets$ \LCOFindSubNode($\hat v$, $\hat e$)
\State \linkcutEvert($\hat v$.$last$)
\If{$\hat v$.$last$ $=$ $s_e$}
\State\Return
\EndIf
\State $x$ $\gets$ \linkcutParent($s_e$)
\State \linkcutDelEdge($s_e$)
\State \linkcutAddEdge($\hat v$.$last$, $\hat v$.$first$)
\State $\hat v$.$first$ $\gets$ $x$; $\hat v$.$last$ $\gets$ $s_e$
\State $T$, $u_{last}$, $T'$ $\gets$ \treapSplit($\hat u$.$last$)
\State $T$ $\gets$ \treapJoin($T'$, $T$, $u_{last}$)
\State $T$.$\node$ $\hat v$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[htb]
\caption{\LCOLink($\hat v$, $\hat w$)}
\label{Algo:LCOLink}
\begin{algorithmic}[1]
\State $x$ $\gets$ \linkcutCreate()
\State $y$ $\gets$ \linkcutCreate()
\If {$\hat v$.$last$ $=$ $\Nil$}
  \State $T$ $\gets$ \treapCreate()
  \State $T$.$\node$ $\gets$ $\hat v$
  \State $\hat v$.$first$ $\gets$ $x$; $\hat v$.$last$ $\gets$ $x$ 
\Else
  \State \linkcutEvert($\hat v$.$last$)
  \State \linkcutAddEdge($\hat v$.$last$, $x$)
  \State $T$ $\gets$ \treapGetRoot($\hat v$.$last$)
  \State $T$ $\gets$ \treapJoin($T$, $x$)
  \State $T$.$\node$ $\gets$ $\hat v$
  \State $\hat v$.$last$ $\gets$ $x$
\EndIf
\If {$\hat w$.$last$ $=$ $\Nil$}
  \State $T$ $\gets$ \treapCreate()
  \State $T$.$\node$ $\gets$ $\hat w$
  \State $\hat w$.$first$ $\gets$ $y$; $\hat w$.$last$ $\gets$ $y$ 
\Else
  \State \linkcutAddEdge($y$, $\hat w$.$first$)
  \State $T$ $\gets$ \treapGetRoot($\hat w$.$last$)
  \State $T$ $\gets$ \treapJoin($y$, $T$)
  \State $T$.$\node$ $\gets$ $\hat w$
  \State $\hat w$.$first$ $\gets$ $y$
\EndIf
\State \linkcutAddEdge($x$, $y$)
\end{algorithmic}
\end{algorithm}


\begin{figure}[htb]
\scalebox{1.5}{
\centering
\input{fig/MSF-basico-4}
}
\caption{As árvores geradoras modificadas que representam o grafo da Figura~\ref{fig:MSF-basico-1}.}
\label{fig:MSF-figura-4}
\end{figure}
